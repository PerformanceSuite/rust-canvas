//! # Drag and Drop Canvas
//! 
//! A comprehensive drag-and-drop audio control widget system built with egui.
//! 
//! This module provides a complete interface for creating, positioning, and managing
//! interactive audio control widgets in a canvas environment. It supports:
//! 
//! - **Multiple Widget Types**: Knobs, sliders, buttons, panels, VU meters, etc.
//! - **Panel Containment**: Widgets can be organized within collapsible panels
//! - **Smart Positioning**: Automatic grid layout with manual positioning override
//! - **Visual Feedback**: Alignment guides and drag hover effects
//! - **Nested Panels**: Panels can contain other panels for complex layouts
//! 
//! ## Example Usage
//! 
//! ```rust
//! let mut canvas = DragDropCanvas::new();
//! 
//! // Add a panel
//! canvas.add_widget(WidgetType::Panel {
//!     title: "MASTER".to_string(),
//!     color: WidgetColor::Cyan,
//!     width: 200.0,
//!     height: 150.0,
//!     collapsed: false,
//!     contained_widgets: Vec::new(),
//! }, Pos2::new(50.0, 50.0));
//! 
//! // Render the canvas
//! canvas.render(ui);
//! ```

use egui::{Color32, Pos2, Rect, Ui, Vec2, FontId, Align2, RichText, Stroke};
use std::f32::consts::PI;
use serde::{Deserialize, Serialize};

// Application version
pub const APP_VERSION: &str = env!("CARGO_PKG_VERSION");

// Positioning constants for better maintainability
const PANEL_MARGIN: f32 = 10.0;
const PANEL_TITLE_HEIGHT: f32 = 40.0;
const CANVAS_MARGIN: f32 = 20.0;
const GRID_SPACING: f32 = 120.0;
const WIDGET_SPACING_IN_PANEL: f32 = 70.0;

// Exact React color palette
const BLACK: Color32 = Color32::from_rgb(0, 0, 0);
const CYAN: Color32 = Color32::from_rgb(6, 182, 212);
const PINK: Color32 = Color32::from_rgb(236, 72, 153);
const GREEN: Color32 = Color32::from_rgb(16, 185, 129);
const YELLOW: Color32 = Color32::from_rgb(245, 158, 11);
const RED: Color32 = Color32::from_rgb(239, 68, 68);
const GRAY_900: Color32 = Color32::from_rgb(17, 24, 39);
const GRAY_800: Color32 = Color32::from_rgb(31, 41, 55);
const GRAY_700: Color32 = Color32::from_rgb(55, 65, 81);
const GRAY_600: Color32 = Color32::from_rgb(75, 85, 99);
const GRAY_400: Color32 = Color32::from_rgb(156, 163, 175);
const WHITE: Color32 = Color32::WHITE;

/// Color themes for widgets matching the React app palette
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum WidgetColor {
    Cyan,
    Pink,
    Green,
    Yellow,
    Red,
}

impl WidgetColor {
    pub fn to_color32(&self) -> Color32 {
        match self {
            WidgetColor::Cyan => CYAN,
            WidgetColor::Pink => PINK,
            WidgetColor::Green => GREEN,
            WidgetColor::Yellow => YELLOW,
            WidgetColor::Red => RED,
        }
    }
}

// State management enum for future refactoring - currently unused
// #[derive(Debug, Clone, PartialEq)]
// pub enum InteractionState {
//     Idle,
//     Dragging { widget_idx: usize, offset: Vec2 },
//     Interacting { widget_idx: usize, last_pos: Pos2 },
//     Resizing { widget_idx: usize, start_size: Vec2, last_pos: Pos2 },
//     PaletteDragging { widget_type: WidgetType, drag_pos: Option<Pos2> },
// }

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum IconType {
    Power,
    Play,
    Pause,
    SkipBack,
    SkipForward,
    Volume,
    Mic,
    Settings,
    Mute,
    Zap,
}

/// Edge snapping positions for settings panels
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum CanvasEdge {
    Left,
    Right,
    Top,
    Bottom,
    None, // For when not snapped to any edge
}

/// All supported widget types with their configuration parameters
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WidgetType {
    Knob { value: f32, min: f32, max: f32, label: String, color: WidgetColor },
    ToggleSwitch { on: bool, label: String, color: WidgetColor, glow: bool },
    PushButton { active: bool, icon: String, label: String, color: WidgetColor, size: f32 },
    VuMeter { level: f32, peak_level: f32, label: String, color: WidgetColor },
    HorizontalSlider { value: f32, min: f32, max: f32, label: String, color: WidgetColor },
    VerticalSlider { value: f32, min: f32, max: f32, label: String, color: WidgetColor },
    LevelIndicator { level: f32, segments: usize, label: String },
    TextLabel { text: String, size: f32, color: WidgetColor },
    Panel { title: String, color: WidgetColor, width: f32, height: f32, collapsed: bool, contained_widgets: Vec<usize>, minimize_to_settings_icon: bool },
    StatusBar { cpu: f32, ram: f32, latency: f32, online: bool },
    IconButton { icon: IconType, label: String, active: bool, color: WidgetColor, size: f32 },
    Settings { label: String, color: WidgetColor },
}

/// A widget instance with position, size, and type information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DraggableWidget {
    pub id: usize,
    pub widget_type: WidgetType,
    pub position: Pos2,
    pub size: Vec2,
}

impl DraggableWidget {
    pub fn new(id: usize, widget_type: WidgetType, position: Pos2) -> Self {
        let size = Self::calculate_size(&widget_type);
        Self {
            id,
            widget_type,
            position,
            size,
        }
    }

    pub fn calculate_size(widget_type: &WidgetType) -> Vec2 {
        match widget_type {
            WidgetType::Knob { .. } => Vec2::new(104.0, 124.0),
            WidgetType::ToggleSwitch { .. } => Vec2::new(68.0, 49.0),
            WidgetType::PushButton { size, .. } => Vec2::new(size + 10.0, size + 30.0),
            WidgetType::VuMeter { .. } => Vec2::new(26.0, 158.0),
            WidgetType::HorizontalSlider { .. } => Vec2::new(176.0, 28.0),
            WidgetType::VerticalSlider { .. } => Vec2::new(28.0, 146.0),
            WidgetType::LevelIndicator { .. } => Vec2::new(120.0, 40.0),
            WidgetType::TextLabel { size, .. } => Vec2::new(size * 8.0, size * 1.5),
            WidgetType::Panel { width, height, collapsed, minimize_to_settings_icon, .. } => {
                if *collapsed {
                    if *minimize_to_settings_icon {
                        Vec2::new(40.0, 40.0) // Settings icon size when minimized with special setting
                    } else {
                        Vec2::new(*width, 40.0) // Just title bar height when collapsed normally
                    }
                } else {
                    Vec2::new(*width, *height)
                }
            },
            WidgetType::StatusBar { .. } => Vec2::new(400.0, 60.0),
            WidgetType::IconButton { size, .. } => Vec2::new(size + 10.0, size + 30.0),
            WidgetType::Settings { .. } => Vec2::new(40.0, 40.0),
        }
    }

    pub fn get_rect(&self) -> Rect {
        Rect::from_min_size(self.position, self.size)
    }

    pub fn render(&mut self, ui: &mut Ui) {
        let rect = self.get_rect();
        let painter = ui.painter();

        match &mut self.widget_type {
            WidgetType::Knob { value, min, max, label, color } => {
                Self::render_knob(painter, rect, value, *min, *max, label, *color);
            }
            WidgetType::ToggleSwitch { on, label, color, glow } => {
                Self::render_toggle_switch(painter, rect, on, label, *color, *glow);
            }
            WidgetType::PushButton { active, icon, label, color, size } => {
                Self::render_push_button(painter, rect, active, icon, label, *color, *size);
            }
            WidgetType::VuMeter { level, peak_level, label, color } => {
                Self::render_vu_meter(painter, rect, *level, peak_level, label, *color);
            }
            WidgetType::HorizontalSlider { value, min, max, label, color } => {
                Self::render_horizontal_slider(painter, rect, value, *min, *max, label, *color);
            }
            WidgetType::VerticalSlider { value, min, max, label, color } => {
                Self::render_vertical_slider(painter, rect, value, *min, *max, label, *color);
            }
            WidgetType::LevelIndicator { level, segments, label } => {
                Self::render_level_indicator(painter, rect, *level, *segments, label);
            }
            WidgetType::TextLabel { text, size, color } => {
                Self::render_text_label(painter, rect, text, *size, *color);
            }
            WidgetType::Panel { title, color, collapsed, contained_widgets, minimize_to_settings_icon, .. } => {
                Self::render_panel(painter, rect, title, *color, *collapsed, contained_widgets, *minimize_to_settings_icon);
            }
            WidgetType::StatusBar { cpu, ram, latency, online } => {
                Self::render_status_bar(painter, rect, *cpu, *ram, *latency, *online);
            }
            WidgetType::IconButton { icon, label, active, color, size } => {
                Self::render_icon_button(painter, rect, *icon, label, active, *color, *size);
            }
            WidgetType::Settings { label, color } => {
                Self::render_settings_widget(painter, rect, label, *color);
            }
        }
    }

    fn render_knob(painter: &egui::Painter, rect: Rect, value: &mut f32, min: f32, max: f32, label: &str, color: WidgetColor) {
        let knob_rect = Rect::from_center_size(
            Pos2::new(rect.center().x, rect.top() + 37.0),
            Vec2::splat(64.0),
        );
        let center = knob_rect.center();
        let radius = 32.0;
        let normalized = (*value - min) / (max - min);
        let angle = normalized * 270.0 * PI / 180.0 - 135.0 * PI / 180.0;

        // Draw outer ring
        painter.circle_filled(center, radius, GRAY_900);
        painter.circle_stroke(center, radius, Stroke::new(4.0, GRAY_700));

        // Draw progress arc
        let arc_points = 32;
        let start_angle = -135.0 * PI / 180.0;
        let end_angle = start_angle + normalized * 270.0 * PI / 180.0;
        
        for i in 0..arc_points {
            let t = i as f32 / (arc_points - 1) as f32;
            let a = start_angle + t * (end_angle - start_angle);
            let inner_radius = radius - 8.0;
            let outer_radius = radius - 4.0;
            
            let inner_pos = center + Vec2::new(a.cos() * inner_radius, a.sin() * inner_radius);
            let outer_pos = center + Vec2::new(a.cos() * outer_radius, a.sin() * outer_radius);
            
            painter.line_segment([inner_pos, outer_pos], Stroke::new(2.0, color.to_color32()));
        }

        // Draw inner circle
        painter.circle_filled(center, radius - 12.0, GRAY_900);

        // Draw indicator line
        let indicator_length = radius - 16.0;
        let indicator_pos = center + Vec2::new(
            angle.cos() * indicator_length,
            angle.sin() * indicator_length,
        );
        painter.line_segment([center, indicator_pos], Stroke::new(4.0, color.to_color32()));

        // Draw center dot
        painter.circle_filled(center, 4.0, color.to_color32());

        // Draw label
        painter.text(
            Pos2::new(center.x, rect.bottom() - 30.0),
            Align2::CENTER_CENTER,
            label,
            FontId::monospace(10.0),
            GRAY_400,
        );

        // Draw value
        painter.text(
            Pos2::new(center.x, rect.bottom() - 15.0),
            Align2::CENTER_CENTER,
            format!("{:.1}", value),
            FontId::monospace(10.0),
            color.to_color32(),
        );
    }

    fn render_toggle_switch(painter: &egui::Painter, rect: Rect, on: &mut bool, label: &str, color: WidgetColor, glow: bool) {
        let switch_rect = Rect::from_center_size(
            Pos2::new(rect.center().x, rect.top() + 17.0),
            Vec2::new(48.0, 24.0),
        );
        let radius = 12.0;
        
        let bg_color = if *on { color.to_color32() } else { GRAY_700 };

        // Draw glow effect if on
        if *on && glow {
            let glow_color = Color32::from_rgba_unmultiplied(
                color.to_color32().r(),
                color.to_color32().g(),
                color.to_color32().b(),
                30
            );
            for i in 1..=3 {
                let glow_rect = switch_rect.expand(i as f32 * 2.0);
                painter.rect_filled(glow_rect, radius + i as f32 * 2.0, glow_color);
            }
        }

        // Draw switch background
        painter.rect_filled(switch_rect, radius, bg_color);

        // Draw switch handle
        let handle_radius = 10.0;
        let handle_x = if *on {
            switch_rect.right() - radius
        } else {
            switch_rect.left() + radius
        };

        painter.circle_filled(
            Pos2::new(handle_x, switch_rect.center().y),
            handle_radius,
            WHITE,
        );

        // Draw shadow for active state
        if *on {
            // Glow for handle
            if glow {
                let handle_glow = Color32::from_rgba_unmultiplied(255, 255, 255, 20);
                painter.circle_filled(
                    Pos2::new(handle_x, switch_rect.center().y),
                    handle_radius + 3.0,
                    handle_glow,
                );
            }
        }

        // Draw label
        if !label.is_empty() {
            painter.text(
                Pos2::new(rect.center().x, rect.bottom() - 10.0),
                Align2::CENTER_CENTER,
                label,
                FontId::monospace(10.0),
                GRAY_400,
            );
        }
    }

    fn render_push_button(painter: &egui::Painter, rect: Rect, active: &mut bool, icon: &str, label: &str, color: WidgetColor, size: f32) {
        let button_rect = Rect::from_center_size(
            Pos2::new(rect.center().x, rect.top() + size / 2.0 + 5.0),
            Vec2::splat(size),
        );

        let (fill_color, _stroke_color) = if *active {
            (Color32::from_rgba_unmultiplied(color.to_color32().r(), color.to_color32().g(), color.to_color32().b(), 60), color.to_color32())
        } else {
            (GRAY_800, GRAY_600)
        };

        // Draw button background
        painter.rect_filled(button_rect, 12.0, fill_color);
        
        // No borders for push buttons

        // Draw icon
        let icon_color = if *active { color.to_color32() } else { GRAY_400 };
        painter.text(
            button_rect.center(),
            Align2::CENTER_CENTER,
            icon,
            FontId::monospace(20.0),
            icon_color,
        );

        // Draw label
        painter.text(
            Pos2::new(rect.center().x, rect.bottom() - 10.0),
            Align2::CENTER_CENTER,
            label,
            FontId::monospace(8.0),
            GRAY_400,
        );
    }

    fn render_vu_meter(painter: &egui::Painter, rect: Rect, level: f32, peak_level: &mut f32, label: &str, color: WidgetColor) {
        let meter_rect = Rect::from_center_size(
            Pos2::new(rect.center().x, rect.top() + 69.0),
            Vec2::new(16.0, 128.0),
        );

        // Update peak level
        if level > *peak_level {
            *peak_level = level;
        } else {
            *peak_level = (*peak_level - 0.5).max(0.0);
        }

        // Draw background
        painter.rect_filled(meter_rect, 4.0, GRAY_800);
        
        // No borders for VU meters

        // Draw level segments
        let segments = 20;
        let segment_height = 128.0 / segments as f32;
        let current_segments = ((level / 100.0) * segments as f32) as usize;

        for i in 0..segments {
            let segment_rect = Rect::from_min_size(
                Pos2::new(
                    meter_rect.left() + 2.0,
                    meter_rect.bottom() - (i + 1) as f32 * segment_height,
                ),
                Vec2::new(12.0, segment_height - 1.0),
            );

            if i < current_segments {
                let segment_color = if i >= 18 {
                    RED
                } else if i >= 14 {
                    YELLOW
                } else {
                    color.to_color32()
                };
                painter.rect_filled(segment_rect, 1.0, segment_color);
            }
        }

        // Draw peak indicator
        if *peak_level > 0.0 {
            let peak_y = meter_rect.bottom() - (*peak_level / 100.0) * 128.0;
            painter.line_segment(
                [
                    Pos2::new(meter_rect.left() + 2.0, peak_y),
                    Pos2::new(meter_rect.right() - 2.0, peak_y),
                ],
                Stroke::new(2.0, WHITE),
            );
        }

        // Draw label
        painter.text(
            Pos2::new(rect.center().x, rect.bottom() - 10.0),
            Align2::CENTER_CENTER,
            label,
            FontId::monospace(10.0),
            GRAY_400,
        );
    }

    fn render_horizontal_slider(painter: &egui::Painter, rect: Rect, value: &mut f32, min: f32, max: f32, label: &str, color: WidgetColor) {
        let normalized = (*value - min) / (max - min);

        // Draw label
        painter.text(
            Pos2::new(rect.left() + 25.0, rect.center().y),
            Align2::CENTER_CENTER,
            label,
            FontId::monospace(10.0),
            GRAY_400,
        );

        let slider_rect = Rect::from_center_size(
            Pos2::new(rect.center().x + 10.0, rect.center().y),
            Vec2::new(96.0, 8.0),
        );

        // Draw background
        painter.rect_filled(slider_rect, 4.0, GRAY_700);

        // Draw filled portion
        let fill_width = slider_rect.width() * normalized;
        let fill_rect = Rect::from_min_size(
            slider_rect.min,
            Vec2::new(fill_width, slider_rect.height()),
        );
        painter.rect_filled(fill_rect, 4.0, color.to_color32());

        // Draw value
        painter.text(
            Pos2::new(rect.right() - 15.0, rect.center().y),
            Align2::CENTER_CENTER,
            format!("{:.0}", value),
            FontId::monospace(10.0),
            color.to_color32(),
        );
    }

    fn render_vertical_slider(painter: &egui::Painter, rect: Rect, value: &mut f32, min: f32, max: f32, _label: &str, color: WidgetColor) {
        let normalized = (*value - min) / (max - min);

        let slider_rect = Rect::from_center_size(
            Pos2::new(rect.center().x, rect.center().y - 10.0),
            Vec2::new(8.0, 96.0),
        );

        // Draw background
        painter.rect_filled(slider_rect, 4.0, GRAY_700);

        // Draw filled portion
        let fill_height = slider_rect.height() * normalized;
        let fill_rect = Rect::from_min_size(
            Pos2::new(slider_rect.left(), slider_rect.bottom() - fill_height),
            Vec2::new(slider_rect.width(), fill_height),
        );
        painter.rect_filled(fill_rect, 4.0, color.to_color32());

        // Draw value
        painter.text(
            Pos2::new(rect.center().x, rect.bottom() - 15.0),
            Align2::CENTER_CENTER,
            format!("{:.0}", value),
            FontId::monospace(8.0),
            color.to_color32(),
        );
    }

    fn render_level_indicator(painter: &egui::Painter, rect: Rect, level: f32, segments: usize, label: &str) {
        let colors = vec![GREEN, GREEN, GREEN, GREEN, GREEN, YELLOW, YELLOW, RED];
        let indicator_rect = Rect::from_center_size(
            Pos2::new(rect.center().x, rect.center().y - 5.0),
            Vec2::new(rect.width() - 20.0, 20.0)
        );
        let segment_width = (indicator_rect.width() - (segments - 1) as f32) / segments as f32;
        let active_segments = ((level / 100.0) * segments as f32) as usize;

        for i in 0..segments {
            let x = indicator_rect.left() + i as f32 * (segment_width + 1.0);
            let segment_rect = Rect::from_min_size(
                Pos2::new(x, indicator_rect.top()),
                Vec2::new(segment_width, indicator_rect.height()),
            );

            let color = if i < active_segments {
                colors.get(i).copied().unwrap_or(GREEN)
            } else {
                GRAY_600
            };

            painter.rect_filled(segment_rect, 1.0, color);
            
            // Add glow effect for active segments
            if i < active_segments {
                let glow_color = Color32::from_rgba_unmultiplied(color.r(), color.g(), color.b(), 20);
                painter.rect_filled(segment_rect.expand(2.0), 1.0, glow_color);
            }
        }
        
        // Draw label
        if !label.is_empty() {
            painter.text(
                Pos2::new(rect.left() + 10.0, rect.center().y),
                Align2::LEFT_CENTER,
                label,
                FontId::monospace(10.0),
                GRAY_400,
            );
        }
    }

    fn render_text_label(painter: &egui::Painter, rect: Rect, text: &str, size: f32, color: WidgetColor) {
        painter.text(
            rect.center(),
            Align2::CENTER_CENTER,
            text,
            FontId::monospace(size),
            color.to_color32(),
        );
    }

    fn render_panel(painter: &egui::Painter, rect: Rect, title: &str, color: WidgetColor, collapsed: bool, contained_widgets: &Vec<usize>, minimize_to_settings_icon: bool) {
        // Draw panel background (matching React's gray-900)
        painter.rect_filled(rect, 16.0, GRAY_900);
        
        // No borders for panels

        // Draw gradient background
        let gradient_color = Color32::from_rgba_unmultiplied(
            color.to_color32().r(),
            color.to_color32().g(),
            color.to_color32().b(),
            10
        );
        painter.rect_filled(rect.shrink(1.0), 16.0, gradient_color);

        if collapsed && minimize_to_settings_icon {
            // Show settings icon when minimized with special setting
            painter.text(
                rect.center(),
                Align2::CENTER_CENTER,
                "âš™ï¸",
                FontId::monospace(20.0),
                color.to_color32(),
            );
        } else {
            // Normal panel rendering
            // Draw title with collapse indicator
            let title_text = if collapsed {
                format!("â–¶ {}", title)
            } else {
                format!("â–¼ {}", title)
            };
            
            painter.text(
                Pos2::new(rect.left() + 10.0, rect.top() + 20.0),
                Align2::LEFT_CENTER,
                &title_text,
                FontId::monospace(14.0),
                color.to_color32(),
            );
        }
        
        // Show widget count for panels
        if !contained_widgets.is_empty() {
            painter.text(
                Pos2::new(rect.right() - 60.0, rect.top() + 20.0),
                Align2::CENTER_CENTER,
                &format!("({})", contained_widgets.len()),
                FontId::monospace(10.0),
                GRAY_400,
            );
        }
        
        // Only draw resize handle if not collapsed
        if !collapsed {
            let handle_size = 12.0;
            let handle_rect = Rect::from_min_size(
                Pos2::new(rect.max.x - handle_size, rect.max.y - handle_size),
                Vec2::splat(handle_size),
            );
            
            // Draw resize handle lines
            for i in 0..3 {
                let offset = i as f32 * 3.0;
                painter.line_segment(
                    [
                        Pos2::new(handle_rect.min.x + offset, handle_rect.max.y - 2.0),
                        Pos2::new(handle_rect.max.x - 2.0, handle_rect.min.y + offset),
                    ],
                    Stroke::new(1.0, GRAY_600),
                );
            }
        }
    }

    fn render_status_bar(painter: &egui::Painter, rect: Rect, cpu: f32, ram: f32, latency: f32, online: bool) {
        // Background
        painter.rect_filled(rect, 8.0, GRAY_900);
        
        // No borders for status bar
        
        // Online indicator
        let indicator_pos = Pos2::new(rect.left() + 15.0, rect.center().y);
        let indicator_color = if online { GREEN } else { RED };
        painter.circle_filled(indicator_pos, 4.0, indicator_color);
        
        // Pulsing effect for online
        if online {
            let pulse_color = Color32::from_rgba_unmultiplied(
                indicator_color.r(),
                indicator_color.g(),
                indicator_color.b(),
                50
            );
            painter.circle_filled(indicator_pos, 6.0, pulse_color);
        }
        
        // Status text
        painter.text(
            Pos2::new(rect.left() + 30.0, rect.center().y),
            Align2::LEFT_CENTER,
            if online { "SYSTEM ONLINE" } else { "SYSTEM OFFLINE" },
            FontId::monospace(10.0),
            indicator_color,
        );
        
        // System stats
        painter.text(
            Pos2::new(rect.center().x - 50.0, rect.center().y),
            Align2::CENTER_CENTER,
            "48kHz / 24-bit",
            FontId::monospace(10.0),
            CYAN,
        );
        
        painter.text(
            Pos2::new(rect.center().x + 50.0, rect.center().y),
            Align2::CENTER_CENTER,
            format!("LATENCY: {:.1}ms", latency),
            FontId::monospace(10.0),
            PINK,
        );
        
        painter.text(
            Pos2::new(rect.right() - 120.0, rect.center().y),
            Align2::CENTER_CENTER,
            format!("CPU: {:.0}%", cpu),
            FontId::monospace(10.0),
            YELLOW,
        );
        
        painter.text(
            Pos2::new(rect.right() - 50.0, rect.center().y),
            Align2::CENTER_CENTER,
            format!("RAM: {:.1}GB", ram),
            FontId::monospace(10.0),
            GREEN,
        );
        
        // Draw resize handle in bottom-right corner
        let handle_size = 12.0;
        let handle_rect = Rect::from_min_size(
            Pos2::new(rect.max.x - handle_size, rect.max.y - handle_size),
            Vec2::splat(handle_size),
        );
        
        // Draw resize handle lines
        for i in 0..3 {
            let offset = i as f32 * 3.0;
            painter.line_segment(
                [
                    Pos2::new(handle_rect.min.x + offset, handle_rect.max.y - 2.0),
                    Pos2::new(handle_rect.max.x - 2.0, handle_rect.min.y + offset),
                ],
                Stroke::new(1.0, GRAY_600),
            );
        }
    }

    fn render_icon_button(painter: &egui::Painter, rect: Rect, icon: IconType, label: &str, active: &mut bool, color: WidgetColor, size: f32) {
        let button_rect = Rect::from_center_size(
            Pos2::new(rect.center().x, rect.top() + size / 2.0 + 5.0),
            Vec2::splat(size),
        );

        // All icon buttons have transparent background
        let icon_color = if *active {
            color.to_color32()
        } else {
            GRAY_400
        };
        
        // No background or border for any icon buttons
        let fill_color = Color32::TRANSPARENT;
        let stroke_color = Color32::TRANSPARENT;

        // Draw button background (only if not transparent)
        if fill_color != Color32::TRANSPARENT {
            painter.rect_filled(button_rect, size / 2.0, fill_color);
        }
        
        // Draw border (only if not transparent)
        if stroke_color != Color32::TRANSPARENT {
            let border_width = 2.0;
            for i in 0..4 {
                let border_edge = match i {
                    0 => Rect::from_min_size(button_rect.min, Vec2::new(border_width, button_rect.height())),
                    1 => Rect::from_min_size(Pos2::new(button_rect.max.x - border_width, button_rect.min.y), Vec2::new(border_width, button_rect.height())),
                    2 => Rect::from_min_size(button_rect.min, Vec2::new(button_rect.width(), border_width)),
                    _ => Rect::from_min_size(Pos2::new(button_rect.min.x, button_rect.max.y - border_width), Vec2::new(button_rect.width(), border_width)),
                };
                painter.rect_filled(border_edge, 0.0, stroke_color);
            }
        }

        // Draw icon based on type
        let icon_text = match icon {
            IconType::Power => "â»",
            IconType::Play => "â–¶",
            IconType::Pause => "â¸",
            IconType::SkipBack => "â®",
            IconType::SkipForward => "â­",
            IconType::Volume => "ðŸ”Š",
            IconType::Mic => "ðŸŽ¤",
            IconType::Settings => "âš™",
            IconType::Mute => "ðŸ”‡",
            IconType::Zap => "âš¡",
        };
        
        painter.text(
            button_rect.center(),
            Align2::CENTER_CENTER,
            icon_text,
            FontId::monospace(size / 3.0),
            icon_color,
        );

        // Draw label
        painter.text(
            Pos2::new(rect.center().x, rect.bottom() - 10.0),
            Align2::CENTER_CENTER,
            label,
            FontId::monospace(8.0),
            GRAY_400,
        );
    }

    fn render_settings_panel(painter: &egui::Painter, rect: Rect, title: &str, color: WidgetColor, minimized: bool, edge: CanvasEdge, _contained_widgets: &Vec<usize>) {
        if minimized {
            // Render minimized state - just a settings icon
            let icon_color = color.to_color32();
            
            // Draw semi-transparent background for the icon
            painter.rect_filled(rect, 8.0, Color32::from_rgba_unmultiplied(0, 0, 0, 120));
            
            // Draw settings icon
            painter.text(
                rect.center(),
                Align2::CENTER_CENTER,
                "âš™ï¸",
                FontId::monospace(24.0),
                icon_color,
            );
        } else {
            // Render expanded state - full panel
            // Draw panel background (solid black)
            painter.rect_filled(rect, 16.0, BLACK);
            
            // Draw border around the panel
            let border_stroke = Stroke::new(2.0, color.to_color32());
            // Top border
            painter.line_segment([rect.left_top(), rect.right_top()], border_stroke);
            // Right border  
            painter.line_segment([rect.right_top(), rect.right_bottom()], border_stroke);
            // Bottom border
            painter.line_segment([rect.right_bottom(), rect.left_bottom()], border_stroke);
            // Left border
            painter.line_segment([rect.left_bottom(), rect.left_top()], border_stroke);

            // Draw title bar with minimize button
            let title_height = 30.0;
            let _title_rect = Rect::from_min_size(rect.min, Vec2::new(rect.width(), title_height));
            
            // Draw title
            painter.text(
                Pos2::new(rect.left() + 10.0, rect.top() + 15.0),
                Align2::LEFT_CENTER,
                title,
                FontId::monospace(12.0),
                color.to_color32(),
            );
            
            // Draw minimize button (X) in top-right
            let close_button_size = 20.0;
            let close_button_pos = Pos2::new(
                rect.right() - close_button_size - 5.0,
                rect.top() + 5.0
            );
            let close_rect = Rect::from_min_size(close_button_pos, Vec2::splat(close_button_size));
            
            painter.rect_filled(close_rect, 4.0, Color32::from_rgba_unmultiplied(255, 255, 255, 30));
            painter.text(
                close_rect.center(),
                Align2::CENTER_CENTER,
                "âˆ’",
                FontId::monospace(12.0),
                WHITE,
            );
            
            // Draw edge indicator based on snapped edge
            let indicator_color = match edge {
                CanvasEdge::Left => CYAN,
                CanvasEdge::Right => PINK,
                CanvasEdge::Top => GREEN,
                CanvasEdge::Bottom => YELLOW,
                CanvasEdge::None => GRAY_600,
            };
            
            // Draw edge indicator line
            match edge {
                CanvasEdge::Left => {
                    painter.line_segment(
                        [Pos2::new(rect.left(), rect.top()), Pos2::new(rect.left(), rect.bottom())],
                        Stroke::new(3.0, indicator_color),
                    );
                }
                CanvasEdge::Right => {
                    painter.line_segment(
                        [Pos2::new(rect.right(), rect.top()), Pos2::new(rect.right(), rect.bottom())],
                        Stroke::new(3.0, indicator_color),
                    );
                }
                CanvasEdge::Top => {
                    painter.line_segment(
                        [Pos2::new(rect.left(), rect.top()), Pos2::new(rect.right(), rect.top())],
                        Stroke::new(3.0, indicator_color),
                    );
                }
                CanvasEdge::Bottom => {
                    painter.line_segment(
                        [Pos2::new(rect.left(), rect.bottom()), Pos2::new(rect.right(), rect.bottom())],
                        Stroke::new(3.0, indicator_color),
                    );
                }
                CanvasEdge::None => {} // No indicator for unsnapped panels
            }
            
            // Draw resize handle based on edge
            match edge {
                CanvasEdge::Left => {
                    // Right edge resize handle for width
                    let handle_size = 8.0;
                    let handle_rect = Rect::from_center_size(
                        Pos2::new(rect.right(), rect.center().y),
                        Vec2::new(handle_size, 60.0),
                    );
                    painter.rect_filled(handle_rect, 2.0, GRAY_600);
                    
                    // Draw resize indicator lines
                    for i in 0..3 {
                        let y_offset = (i as f32 - 1.0) * 8.0;
                        painter.line_segment(
                            [
                                Pos2::new(handle_rect.center().x - 2.0, handle_rect.center().y + y_offset),
                                Pos2::new(handle_rect.center().x + 2.0, handle_rect.center().y + y_offset),
                            ],
                            Stroke::new(1.0, WHITE),
                        );
                    }
                }
                CanvasEdge::Right => {
                    // Left edge resize handle for width
                    let handle_size = 8.0;
                    let handle_rect = Rect::from_center_size(
                        Pos2::new(rect.left(), rect.center().y),
                        Vec2::new(handle_size, 60.0),
                    );
                    painter.rect_filled(handle_rect, 2.0, GRAY_600);
                    
                    // Draw resize indicator lines
                    for i in 0..3 {
                        let y_offset = (i as f32 - 1.0) * 8.0;
                        painter.line_segment(
                            [
                                Pos2::new(handle_rect.center().x - 2.0, handle_rect.center().y + y_offset),
                                Pos2::new(handle_rect.center().x + 2.0, handle_rect.center().y + y_offset),
                            ],
                            Stroke::new(1.0, WHITE),
                        );
                    }
                }
                CanvasEdge::Top => {
                    // Bottom edge resize handle for height
                    let handle_size = 8.0;
                    let handle_rect = Rect::from_center_size(
                        Pos2::new(rect.center().x, rect.bottom()),
                        Vec2::new(60.0, handle_size),
                    );
                    painter.rect_filled(handle_rect, 2.0, GRAY_600);
                    
                    // Draw resize indicator lines
                    for i in 0..3 {
                        let x_offset = (i as f32 - 1.0) * 8.0;
                        painter.line_segment(
                            [
                                Pos2::new(handle_rect.center().x + x_offset, handle_rect.center().y - 2.0),
                                Pos2::new(handle_rect.center().x + x_offset, handle_rect.center().y + 2.0),
                            ],
                            Stroke::new(1.0, WHITE),
                        );
                    }
                }
                CanvasEdge::Bottom => {
                    // Top edge resize handle for height
                    let handle_size = 8.0;
                    let handle_rect = Rect::from_center_size(
                        Pos2::new(rect.center().x, rect.top()),
                        Vec2::new(60.0, handle_size),
                    );
                    painter.rect_filled(handle_rect, 2.0, GRAY_600);
                    
                    // Draw resize indicator lines
                    for i in 0..3 {
                        let x_offset = (i as f32 - 1.0) * 8.0;
                        painter.line_segment(
                            [
                                Pos2::new(handle_rect.center().x + x_offset, handle_rect.center().y - 2.0),
                                Pos2::new(handle_rect.center().x + x_offset, handle_rect.center().y + 2.0),
                            ],
                            Stroke::new(1.0, WHITE),
                        );
                    }
                }
                CanvasEdge::None => {} // No resize handle for unsnapped panels
            }
            
            // No content text - clean canvas area
        }
    }
}


/// Main canvas for drag-and-drop widget management
/// 
/// Handles all widget positioning, interaction states, and rendering.
/// Supports nested panels, smart positioning, and visual feedback.
pub struct DragDropCanvas {
    pub widgets: Vec<DraggableWidget>,
    pub next_id: usize,
    pub canvas_rect: Rect,
    pub editing_widget: Option<usize>, // Index of widget being edited
    pub show_edit_window: bool,
    
    // Panel selection state
    pub selected_panel: Option<usize>, // ID of currently selected panel for widget placement
    pub pending_widget: Option<WidgetType>, // Widget type selected from palette, waiting to be placed
    
    // Drag and drop state (cleaned up but kept compatible)
    pub dragging_widget: Option<usize>, // Index of currently dragging widget
    pub drag_offset: Vec2,
    pub interacting_widget: Option<usize>, // Index of widget being interacted with
    pub last_mouse_pos: Option<Pos2>,
    pub resizing_widget: Option<usize>, // Index of widget being resized
    pub resize_start_size: Vec2, // Original size when resize started
    pub palette_dragging: Option<WidgetType>, // Widget type being dragged from palette
    pub palette_drag_pos: Option<Pos2>, // Current position of palette drag
    
    // Visual feedback
    pub alignment_guides: Vec<AlignmentGuide>,
    pub drag_hover_panel: Option<usize>, // Panel being hovered over during drag
    pub needs_repositioning: bool, // Whether canvas widgets need to be repositioned
}

#[derive(Debug, Clone)]
pub struct AlignmentGuide {
    pub start: Pos2,
    pub end: Pos2,
    pub guide_type: AlignmentType,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum AlignmentType {
    CenterHorizontal, // Pink - centered on canvas
    CenterVertical,   // Pink - centered on canvas
    WidgetAlignHorizontal, // Yellow - aligned with other widget
    WidgetAlignVertical,   // Yellow - aligned with other widget
}

impl Default for DragDropCanvas {
    fn default() -> Self {
        Self {
            widgets: Vec::new(),
            next_id: 0,
            canvas_rect: Rect::NOTHING,
            editing_widget: None,
            show_edit_window: false,
            selected_panel: None,
            pending_widget: None,
            dragging_widget: None,
            drag_offset: Vec2::ZERO,
            interacting_widget: None,
            last_mouse_pos: None,
            resizing_widget: None,
            resize_start_size: Vec2::ZERO,
            palette_dragging: None,
            palette_drag_pos: None,
            alignment_guides: Vec::new(),
            drag_hover_panel: None,
            needs_repositioning: false,
        }
    }
}

// Panel containment management
impl DragDropCanvas {
    /// Check if a widget is contained within any panel
    fn is_widget_contained(&self, widget_id: usize) -> bool {
        self.widgets.iter().any(|panel| {
            match &panel.widget_type {
                WidgetType::Panel { contained_widgets, .. } |
                WidgetType::Panel { contained_widgets, .. } => {
                    contained_widgets.contains(&widget_id)
                }
                _ => false,
            }
        })
    }
    
    /// Get the list of widgets not contained in any panel (canvas widgets)
    fn get_canvas_widgets(&self) -> Vec<usize> {
        self.widgets.iter()
            .enumerate()
            .filter_map(|(idx, widget)| {
                if !self.is_widget_contained(widget.id) {
                    Some(idx)
                } else {
                    None
                }
            })
            .collect()
    }
    
    /// Check if a panel can accept widgets (not collapsed/minimized)
    fn is_panel_accepting_widgets(&self, panel_widget: &DraggableWidget) -> bool {
        match &panel_widget.widget_type {
            WidgetType::Panel { collapsed, .. } => !collapsed,
            _ => false,
        }
    }
    
    /// Add a widget to a panel's contained widgets list
    fn add_widget_to_panel(&mut self, panel_idx: usize, widget_id: usize) -> bool {
        if let Some(panel) = self.widgets.get_mut(panel_idx) {
            match &mut panel.widget_type {
                WidgetType::Panel { contained_widgets, .. } |
                WidgetType::Panel { contained_widgets, .. } => {
                    if !contained_widgets.contains(&widget_id) {
                        contained_widgets.push(widget_id);
                        return true;
                    }
                }
                _ => {}
            }
        }
        false
    }
}

impl DragDropCanvas {
    /// Create a new drag and drop canvas
    pub fn new() -> Self {
        Self::default()
    }
    
    /// Reset all interaction states to idle
    pub fn reset_interactions(&mut self) {
        self.dragging_widget = None;
        self.interacting_widget = None;
        self.resizing_widget = None;
        self.last_mouse_pos = None;
        self.palette_dragging = None;
        self.palette_drag_pos = None;
        self.alignment_guides.clear();
        self.drag_hover_panel = None;
    }
    
    /// Check if any interaction is currently active
    pub fn is_interacting(&self) -> bool {
        self.dragging_widget.is_some() || 
        self.interacting_widget.is_some() || 
        self.resizing_widget.is_some() ||
        self.palette_dragging.is_some()
    }

    fn add_widget_to_selected_panel(&mut self, widget_type: WidgetType, click_pos: Pos2) {
        if let Some(panel_id) = self.selected_panel {
            // Find the panel
            if let Some(panel_idx) = self.widgets.iter().position(|w| w.id == panel_id) {
                let panel_rect = self.widgets[panel_idx].get_rect();
                let widget_size = DraggableWidget::calculate_size(&widget_type);
                
                // Calculate desired position within panel (relative to click)
                let desired_x = click_pos.x.max(panel_rect.left() + PANEL_MARGIN);
                let desired_y = click_pos.y.max(panel_rect.top() + PANEL_TITLE_HEIGHT);
                
                // Ensure widget stays within panel bounds
                let max_x = panel_rect.right() - PANEL_MARGIN - widget_size.x;
                let max_y = panel_rect.bottom() - PANEL_MARGIN - widget_size.y;
                
                let mut final_pos = Pos2::new(
                    desired_x.min(max_x),
                    desired_y.min(max_y)
                );
                
                // Check for overlaps with existing widgets in this panel and adjust position
                let panel_widget_ids = match &self.widgets[panel_idx].widget_type {
                    WidgetType::Panel { contained_widgets, .. } => contained_widgets.clone(),
                    WidgetType::Panel { contained_widgets, .. } => contained_widgets.clone(),
                    _ => Vec::new(),
                };
                
                final_pos = self.find_non_overlapping_position(final_pos, widget_size, &panel_widget_ids, panel_rect);
                
                let widget = DraggableWidget::new(self.next_id, widget_type, final_pos);
                let widget_id = widget.id;
                self.widgets.push(widget);
                self.next_id += 1;
                
                // Add to panel's contained widgets
                self.add_widget_to_panel(panel_idx, widget_id);
            }
        }
    }
    
    fn find_non_overlapping_position(&self, preferred_pos: Pos2, widget_size: Vec2, existing_widget_ids: &[usize], bounds: Rect) -> Pos2 {
        let padding = 1.0; // 1 pixel padding
        let mut test_pos = preferred_pos;
        
        // Check if current position overlaps with any existing widgets
        for &widget_id in existing_widget_ids {
            if let Some(existing_widget) = self.widgets.iter().find(|w| w.id == widget_id) {
                let existing_rect = existing_widget.get_rect().expand(padding);
                let test_rect = Rect::from_min_size(test_pos, widget_size);
                
                if existing_rect.intersects(test_rect) {
                    // Try to the right first
                    test_pos.x = existing_rect.right() + padding;
                    
                    // If that goes outside bounds, try below
                    if test_pos.x + widget_size.x > bounds.right() - PANEL_MARGIN {
                        test_pos.x = preferred_pos.x;
                        test_pos.y = existing_rect.bottom() + padding;
                        
                        // If that goes outside bounds, find first available spot
                        if test_pos.y + widget_size.y > bounds.bottom() - PANEL_MARGIN {
                            test_pos = self.find_first_available_spot(widget_size, existing_widget_ids, bounds);
                        }
                    }
                    break;
                }
            }
        }
        
        test_pos
    }
    
    fn find_first_available_spot(&self, widget_size: Vec2, existing_widget_ids: &[usize], bounds: Rect) -> Pos2 {
        let padding = 1.0;
        let start_x = bounds.left() + PANEL_MARGIN;
        let start_y = bounds.top() + PANEL_TITLE_HEIGHT;
        let step = 20.0; // Grid step for searching
        
        for y in (start_y as i32..(bounds.bottom() - PANEL_MARGIN - widget_size.y) as i32).step_by(step as usize) {
            for x in (start_x as i32..(bounds.right() - PANEL_MARGIN - widget_size.x) as i32).step_by(step as usize) {
                let test_pos = Pos2::new(x as f32, y as f32);
                let test_rect = Rect::from_min_size(test_pos, widget_size);
                
                let mut overlaps = false;
                for &widget_id in existing_widget_ids {
                    if let Some(existing_widget) = self.widgets.iter().find(|w| w.id == widget_id) {
                        if existing_widget.get_rect().expand(padding).intersects(test_rect) {
                            overlaps = true;
                            break;
                        }
                    }
                }
                
                if !overlaps {
                    return test_pos;
                }
            }
        }
        
        // Fallback to preferred position if no spot found
        Pos2::new(start_x, start_y)
    }
    
    pub fn add_widget(&mut self, widget_type: WidgetType, _position: Pos2) {
        // Calculate position immediately if canvas_rect is available, otherwise use safe default
        let position = if self.canvas_rect != Rect::NOTHING {
            // Canvas size is known, calculate proper position right now
            let canvas_widget_count = self.count_canvas_widgets();
            self.calculate_grid_position(canvas_widget_count, &widget_type)
        } else {
            // Canvas size unknown, use safe position and mark for later repositioning
            self.needs_repositioning = true;
            Pos2::new(50.0, 50.0)
        };
        
        let widget = DraggableWidget::new(self.next_id, widget_type, position);
        self.widgets.push(widget);
        self.next_id += 1;
    }
    
    fn count_canvas_widgets(&self) -> usize {
        // Count widgets that are on the main canvas (not in any panel)
        self.widgets.iter()
            .filter(|w| {
                // Check if widget is not contained in any panel
                !self.widgets.iter().any(|panel| {
                    match &panel.widget_type {
                        WidgetType::Panel { contained_widgets, .. } => contained_widgets.contains(&w.id),
                        WidgetType::Panel { contained_widgets, .. } => contained_widgets.contains(&w.id),
                        _ => false,
                    }
                })
            })
            .count()
    }

    pub fn render(&mut self, ui: &mut Ui) {
        // Set canvas background to match React app (black)
        ui.style_mut().visuals.extreme_bg_color = BLACK;
        ui.style_mut().visuals.panel_fill = BLACK;
        
        // Get the actual drawing area after UI elements
        let available_rect = ui.available_rect_before_wrap();
        
        // Account for the UI elements that are drawn before this canvas
        // The canvas starts after heading and instructions, so add offset
        let actual_canvas_start_y = available_rect.min.y + 60.0; // Approximate height of heading + separator + instructions
        let actual_canvas_rect = Rect::from_min_max(
            Pos2::new(available_rect.min.x, actual_canvas_start_y),
            available_rect.max
        );
        
        self.canvas_rect = actual_canvas_rect;
        
        // Reposition canvas widgets if needed (after canvas size is known)
        if self.needs_repositioning {
            self.reposition_canvas_widgets();
            self.needs_repositioning = false;
        }

        // Draw canvas background
        ui.painter().rect_filled(actual_canvas_rect, 0.0, BLACK);

        // Handle drag and drop input
        self.handle_drag_drop(ui);

        // Collect which widgets should be rendered (not in minimized panels)
        let widgets_to_render: Vec<bool> = self.widgets.iter()
            .map(|w| !self.is_widget_in_minimized_panel(w.id))
            .collect();
        
        // Render widgets that should be visible
        for (widget, &should_render) in self.widgets.iter_mut().zip(widgets_to_render.iter()) {
            if should_render {
                widget.render(ui);
            }
        }

        // Draw alignment guides
        let painter = ui.painter();
        for guide in &self.alignment_guides {
            let (color, width) = match guide.guide_type {
                AlignmentType::CenterHorizontal | AlignmentType::CenterVertical => (PINK, 2.0),
                AlignmentType::WidgetAlignHorizontal | AlignmentType::WidgetAlignVertical => (YELLOW, 1.5),
            };
            
            painter.line_segment([guide.start, guide.end], Stroke::new(width, color));
        }

        // Note: Removed visible selection borders around widgets as requested
        
        // Draw hover highlight for panel during drag
        if let Some(hover_panel_id) = self.drag_hover_panel {
            if let Some(hover_panel) = self.widgets.iter().find(|w| w.id == hover_panel_id) {
                let rect = hover_panel.get_rect().expand(2.0);
                let stroke = Stroke::new(3.0, GREEN);
                
                // Draw highlight border using line segments
                painter.line_segment([rect.left_top(), rect.right_top()], stroke);
                painter.line_segment([rect.right_top(), rect.right_bottom()], stroke);
                painter.line_segment([rect.right_bottom(), rect.left_bottom()], stroke);
                painter.line_segment([rect.left_bottom(), rect.left_top()], stroke);
            }
        }
        
        // Draw selection highlight
        if let Some(selected_panel_id) = self.selected_panel {
            // Highlight selected panel with cyan
            if let Some(selected_panel) = self.widgets.iter().find(|w| w.id == selected_panel_id) {
                let rect = selected_panel.get_rect().expand(2.0);
                let stroke = Stroke::new(3.0, CYAN);
                
                // Draw highlight border using line segments
                painter.line_segment([rect.left_top(), rect.right_top()], stroke);
                painter.line_segment([rect.right_top(), rect.right_bottom()], stroke);
                painter.line_segment([rect.right_bottom(), rect.left_bottom()], stroke);
                painter.line_segment([rect.left_bottom(), rect.left_top()], stroke);
            }
        } else {
            // No panel selected - highlight main canvas with yellow
            let canvas_rect = self.canvas_rect.shrink(5.0); // Slight inset
            let stroke = Stroke::new(2.0, YELLOW);
            
            // Draw highlight border around canvas
            painter.line_segment([canvas_rect.left_top(), canvas_rect.right_top()], stroke);
            painter.line_segment([canvas_rect.right_top(), canvas_rect.right_bottom()], stroke);
            painter.line_segment([canvas_rect.right_bottom(), canvas_rect.left_bottom()], stroke);
            painter.line_segment([canvas_rect.left_bottom(), canvas_rect.left_top()], stroke);
        }

        // Draw static settings icon in top-left
        self.render_settings_icon(ui);
        
        
        // Draw palette dragging preview
        if let (Some(widget_type), Some(pos)) = (&self.palette_dragging, self.palette_drag_pos) {
            let size = DraggableWidget::calculate_size(widget_type);
            let preview_rect = Rect::from_min_size(pos - size / 2.0, size);
            
            // Draw semi-transparent preview
            let painter = ui.painter();
            painter.rect_filled(preview_rect, 4.0, Color32::from_rgba_unmultiplied(100, 100, 100, 100));
            
            // Draw widget type label
            painter.text(
                preview_rect.center(),
                Align2::CENTER_CENTER,
                match widget_type {
                    WidgetType::Knob { .. } => "Knob",
                    WidgetType::ToggleSwitch { .. } => "Toggle",
                    WidgetType::PushButton { .. } => "Button",
                    WidgetType::VuMeter { .. } => "VU Meter",
                    WidgetType::HorizontalSlider { .. } => "H Slider",
                    WidgetType::VerticalSlider { .. } => "V Slider",
                    WidgetType::LevelIndicator { .. } => "Level",
                    WidgetType::TextLabel { .. } => "Text",
                    WidgetType::Panel { .. } => "Panel",
                    WidgetType::StatusBar { .. } => "Status",
                    WidgetType::IconButton { .. } => "Icon",
                },
                FontId::monospace(12.0),
                WHITE,
            );
        }
        
        // Show edit window
        if self.show_edit_window {
            self.show_edit_window(ui);
        }
    }

    fn handle_drag_drop(&mut self, ui: &mut Ui) {
        let mouse_pos = ui.ctx().input(|i| i.pointer.interact_pos());
        let mouse_pressed = ui.ctx().input(|i| i.pointer.primary_pressed());
        let mouse_released = ui.ctx().input(|i| i.pointer.primary_released());
        let right_clicked = ui.ctx().input(|i| i.pointer.secondary_pressed());
        let mouse_held = ui.ctx().input(|i| i.pointer.primary_down());
        
        // Handle clicks
        
        // Handle click operations (both widget placement and panel selection)
        if mouse_pressed {
            if let Some(pos) = mouse_pos {
                // Check if on canvas (not on side panel)
                if pos.x > 220.0 { // Beyond the palette width
                    // Check if we clicked on a panel
                    let mut clicked_panel_id = None;
                    for widget in self.widgets.iter().rev() {
                        if widget.get_rect().contains(pos) {
                            match &widget.widget_type {
                                WidgetType::Panel { collapsed, .. } => {
                                    if !collapsed {
                                        clicked_panel_id = Some(widget.id);
                                        break;
                                    }
                                }
                                    if !minimized {
                                        clicked_panel_id = Some(widget.id);
                                        break;
                                    }
                                }
                                _ => {}
                            }
                        }
                    }
                    
                    // Handle the click based on whether we have a pending widget
                    if let Some(widget_type) = self.pending_widget.take() {
                        // We have a pending widget - place it
                        if let Some(panel_id) = clicked_panel_id {
                            // Clicked on a panel - place widget in that panel and select it
                            self.selected_panel = Some(panel_id);
                            self.add_widget_to_selected_panel(widget_type, pos);
                        } else if let Some(_panel_id) = self.selected_panel {
                            // Have a selected panel - place widget there
                            self.add_widget_to_selected_panel(widget_type, pos);
                        } else {
                            // No panel selected - place on canvas
                            self.add_widget(widget_type, pos);
                        }
                        return; // Don't process other operations after placing widget
                    } else {
                        // No pending widget - handle panel selection, but still allow dragging
                        if let Some(panel_id) = clicked_panel_id {
                            self.selected_panel = Some(panel_id);
                            // Don't return here - let dragging logic run for moving panels
                        } else {
                            // Clicked on empty canvas - deselect panel
                            self.selected_panel = None;
                            // Don't return here - let dragging logic run
                        }
                    }
                }
            }
        }
        
        // Handle palette dragging
        if let Some(widget_type) = self.palette_dragging.clone() {
            if let Some(pos) = mouse_pos {
                self.palette_drag_pos = Some(pos);
                
                // If mouse released, drop the widget
                if mouse_released {
                    // Check if dropped on canvas (not on side panel)
                    if pos.x > 220.0 { // Beyond the palette width
                        // Check if we dropped on a panel
                        let mut dropped_on_panel_id = None;
                        for widget in self.widgets.iter().rev() {
                            if widget.get_rect().contains(pos) {
                                match &widget.widget_type {
                                    WidgetType::Panel { collapsed, .. } => {
                                        if !collapsed {
                                            dropped_on_panel_id = Some(widget.id);
                                            break;
                                        }
                                    }
                                        if !minimized {
                                            dropped_on_panel_id = Some(widget.id);
                                            break;
                                        }
                                    }
                                    _ => {}
                                }
                            }
                        }
                        
                        // Place the widget
                        if let Some(panel_id) = dropped_on_panel_id {
                            // Dropped on a panel - place widget in that panel and select it
                            self.selected_panel = Some(panel_id);
                            self.add_widget_to_selected_panel(widget_type, pos);
                        } else if let Some(_panel_id) = self.selected_panel {
                            // Have a selected panel - place widget there
                            self.add_widget_to_selected_panel(widget_type, pos);
                        } else {
                            // No panel selected - place on canvas
                            self.add_widget(widget_type, pos);
                        }
                    }
                    
                    self.palette_dragging = None;
                    self.palette_drag_pos = None;
                }
            }
            return; // Don't process other drag operations while palette dragging
        }

        // Handle right-click for editing
        if right_clicked {
            if let Some(pos) = mouse_pos {
                for (idx, widget) in self.widgets.iter().enumerate().rev() {
                    if widget.get_rect().contains(pos) {
                        self.editing_widget = Some(idx);
                        self.show_edit_window = true;
                        break;
                    }
                }
            }
        }

        // Handle mouse press
        if mouse_pressed && self.dragging_widget.is_none() && self.interacting_widget.is_none() && self.resizing_widget.is_none() {
            if let Some(pos) = mouse_pos {
                // First, assume we clicked on empty space
                let mut _clicked_widget = false;
                
                for (idx, widget) in self.widgets.iter().enumerate().rev() {
                    if widget.get_rect().contains(pos) {
                        // Check if clicking on panel or status bar resize handle
                        if matches!(widget.widget_type, WidgetType::Panel { .. } | WidgetType::StatusBar { .. }) {
                            let rect = widget.get_rect();
                            let handle_size = 12.0;
                            let handle_rect = Rect::from_min_size(
                                Pos2::new(rect.max.x - handle_size, rect.max.y - handle_size),
                                Vec2::splat(handle_size),
                            );
                            
                            if handle_rect.contains(pos) {
                                self.resizing_widget = Some(idx);
                                self.resize_start_size = widget.size;
                                self.last_mouse_pos = Some(pos);
                                break;
                            }
                        }
                        
                                let distance = (pos - knob_center).length();
                                if distance <= 32.0 { // Within knob radius
                                    self.interacting_widget = Some(idx);
                                    self.last_mouse_pos = Some(pos);
                                    break;
                                }
                            }
                            WidgetType::ToggleSwitch { .. } | 
                            WidgetType::PushButton { .. } | 
                            WidgetType::IconButton { .. } => {
                                // These widgets can be both clicked and dragged
                                // For now, just allow dragging - interaction will be handled on mouse release without drag
                            }
                            WidgetType::Panel { .. } => {
                                // Check if clicking on collapse triangle
                                let title_area = Rect::from_min_size(
                                    widget.position,
                                    Vec2::new(widget.size.x, 40.0),
                                );
                                if title_area.contains(pos) && pos.x < widget.position.x + 30.0 {
                                    // Handle Panel collapse click
                                    self.handle_widget_interaction(idx, pos);
                                    return; // Exit early
                                }
                                // Just allow dragging the panel - no area selection
                            }
                            _ => {}
                        }
                        
                        // For non-knob widgets or outside knob center, allow for dragging
                        self.dragging_widget = Some(idx);
                        self.drag_offset = pos - widget.position;
                        _clicked_widget = true;
                        break;
                    }
                }
                
                // No special handling needed for empty space clicks
            }
        }

        // Handle widget interactions (knob turning)
        if let Some(idx) = self.interacting_widget {
            if mouse_held {
                if let (Some(current_pos), Some(last_pos)) = (mouse_pos, self.last_mouse_pos) {
                    let delta_y = last_pos.y - current_pos.y; // Invert for natural feel
                    self.handle_knob_interaction(idx, delta_y);
                    self.last_mouse_pos = Some(current_pos);
                }
            } else {
                self.interacting_widget = None;
                self.last_mouse_pos = None;
            }
        }

        // Handle widget dragging
        if let Some(idx) = self.dragging_widget {
            if mouse_held {
                if let Some(pos) = mouse_pos {
                    // Get widget data first
                    let (widget_size, new_pos) = if let Some(widget) = self.widgets.get(idx) {
                        (widget.size, pos - self.drag_offset)
                    } else {
                        return;
                    };
                    
                    // Check if widget is contained in a Settings Panel and constrain accordingly
                    let mut final_pos = if let Some(container_panel) = self.find_widget_container_panel(idx) {
                        // Constrain to Settings Panel bounds
                        let panel_rect = self.widgets[container_panel].get_rect();
                        let content_area = Rect::from_min_size(
                            Pos2::new(panel_rect.left() + PANEL_MARGIN, panel_rect.top() + PANEL_TITLE_HEIGHT),
                            Vec2::new((panel_rect.width() - PANEL_MARGIN * 2.0).max(50.0), (panel_rect.height() - PANEL_TITLE_HEIGHT - PANEL_MARGIN).max(50.0)),
                        );
                        let max_x = (content_area.max.x - widget_size.x).max(content_area.min.x);
                        let max_y = (content_area.max.y - widget_size.y).max(content_area.min.y);
                        Pos2::new(
                            new_pos.x.clamp(content_area.min.x, max_x),
                            new_pos.y.clamp(content_area.min.y, max_y),
                        )
                    } else {
                        // Constrain to canvas bounds
                        let max_x = (self.canvas_rect.max.x - widget_size.x).max(self.canvas_rect.min.x);
                        let max_y = (self.canvas_rect.max.y - widget_size.y).max(self.canvas_rect.min.y);
                        Pos2::new(
                            new_pos.x.clamp(self.canvas_rect.min.x, max_x),
                            new_pos.y.clamp(self.canvas_rect.min.y, max_y),
                        )
                    };
                    
                    // Calculate alignment guides and snap if close
                    self.calculate_alignment_guides(idx, final_pos, widget_size);
                    
                    // Apply snapping based on guides
                    final_pos = self.apply_snapping(idx, final_pos, widget_size);
                    
                    // Check for panel hover during drag
                    self.drag_hover_panel = self.find_panel_under_position(pos);
                    
                    // Calculate edge snap for SettingsPanel before getting mutable reference
                    let new_edge = if let Some(widget) = self.widgets.get(idx) {
                            self.calculate_edge_snap(final_pos, widget_size)
                        } else {
                            CanvasEdge::None
                        }
                    } else {
                        CanvasEdge::None
                    };
                    
                    // Update widget position
                    if let Some(widget) = self.widgets.get_mut(idx) {
                        widget.position = final_pos;
                        
                        // Handle edge snapping for SettingsPanel
                            // Only update edge, don't resize during drag to prevent flashing
                            let _old_edge = *edge;
                            *edge = new_edge;
                            
                            // During drag, only snap position without resizing to prevent flashing
                            if new_edge != CanvasEdge::None {
                                match new_edge {
                                    CanvasEdge::Left => {
                                        widget.position.x = self.canvas_rect.min.x;
                                    }
                                    CanvasEdge::Right => {
                                        widget.position.x = (self.canvas_rect.max.x - widget.size.x).max(self.canvas_rect.min.x);
                                    }
                                    CanvasEdge::Top => {
                                        widget.position.y = self.canvas_rect.min.y;
                                    }
                                    CanvasEdge::Bottom => {
                                        widget.position.y = (self.canvas_rect.max.y - widget.size.y).max(self.canvas_rect.min.y);
                                    }
                                    _ => {}
                                }
                            } else {
                                // For unsnapped settings panels, ensure they stay within canvas bounds
                                let max_x = (self.canvas_rect.max.x - widget.size.x).max(self.canvas_rect.min.x);
                                let max_y = (self.canvas_rect.max.y - widget.size.y).max(self.canvas_rect.min.y);
                                widget.position.x = widget.position.x.clamp(self.canvas_rect.min.x, max_x);
                                widget.position.y = widget.position.y.clamp(self.canvas_rect.min.y, max_y);
                            }
                        }
                    }
                }
            } else {
                // Mouse released - check if widget should be placed in a panel
                if let Some(dragged_idx) = self.dragging_widget {
                    if let Some(pos) = mouse_pos {
                        self.check_and_place_in_panel(dragged_idx, pos);
                    }
                }
                self.dragging_widget = None;
                self.alignment_guides.clear();
                self.drag_hover_panel = None;
            }
        }

        // Handle widget resizing
        if let Some(idx) = self.resizing_widget {
            if mouse_held {
                if let (Some(current_pos), Some(last_pos)) = (mouse_pos, self.last_mouse_pos) {
                    let delta = current_pos - last_pos;
                    
                    if let Some(widget) = self.widgets.get_mut(idx) {
                        match &mut widget.widget_type {
                            WidgetType::Panel { width, height, .. } => {
                                *width = (*width + delta.x).max(100.0).min(500.0);
                                *height = (*height + delta.y).max(100.0).min(400.0);
                                
                                // Update widget size
                                widget.size = Vec2::new(*width, *height);
                            }
                            WidgetType::StatusBar { .. } => {
                                // Status bars can be resized in width and height
                                let new_width = (widget.size.x + delta.x).max(200.0).min(800.0);
                                let new_height = (widget.size.y + delta.y).max(40.0).min(120.0);
                                
                                // Update widget size
                                widget.size = Vec2::new(new_width, new_height);
                            }
                                match edge {
                                    CanvasEdge::Left => {
                                        // Resize width only, maintain full height
                                        *width = (*width + delta.x).max(150.0).min(400.0);
                                        widget.size = Vec2::new(*width, self.canvas_rect.height());
                                        
                                        // Keep position at left edge
                                        widget.position.x = self.canvas_rect.min.x;
                                        widget.position.y = self.canvas_rect.min.y;
                                    }
                                    CanvasEdge::Right => {
                                        // Resize width only, maintain full height
                                        *width = (*width - delta.x).max(150.0).min(400.0); // Subtract delta for right edge
                                        widget.size = Vec2::new(*width, self.canvas_rect.height());
                                        
                                        // Keep position at right edge
                                        widget.position.x = self.canvas_rect.max.x - widget.size.x;
                                        widget.position.y = self.canvas_rect.min.y;
                                    }
                                    CanvasEdge::Top => {
                                        // Resize height only, maintain full width
                                        *height = (*height + delta.y).max(100.0).min(300.0);
                                        widget.size = Vec2::new(self.canvas_rect.width(), *height);
                                        
                                        // Keep position at top edge
                                        widget.position.x = self.canvas_rect.min.x;
                                        widget.position.y = self.canvas_rect.min.y;
                                    }
                                    CanvasEdge::Bottom => {
                                        // Resize height only, maintain full width
                                        *height = (*height - delta.y).max(100.0).min(300.0); // Subtract delta for bottom edge
                                        widget.size = Vec2::new(self.canvas_rect.width(), *height);
                                        
                                        // Keep position at bottom edge
                                        widget.position.x = self.canvas_rect.min.x;
                                        widget.position.y = self.canvas_rect.max.y - widget.size.y;
                                    }
                                    CanvasEdge::None => {
                                        // Normal resize for unsnapped panels
                                        *width = (*width + delta.x).max(150.0).min(400.0);
                                        *height = (*height + delta.y).max(100.0).min(300.0);
                                        widget.size = Vec2::new(*width, *height);
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    
                    self.last_mouse_pos = Some(current_pos);
                }
            } else {
                self.resizing_widget = None;
                self.last_mouse_pos = None;
            }
        }

        // Handle single clicks for remaining interactive widgets (sliders, status bars)
        if mouse_pressed && self.dragging_widget.is_none() && self.interacting_widget.is_none() && self.resizing_widget.is_none() {
            if let Some(pos) = mouse_pos {
                for i in 0..self.widgets.len() {
                    if self.widgets[i].get_rect().contains(pos) {
                        // Only handle widgets not already handled above
                        match &self.widgets[i].widget_type {
                            WidgetType::Knob { .. } | 
                            WidgetType::ToggleSwitch { .. } | 
                            WidgetType::PushButton { .. } | 
                            WidgetType::IconButton { .. } => {} // Already handled above
                            _ => self.handle_widget_interaction(i, pos),
                        }
                        break;
                    }
                }
            }
        }

        // Stop interactions on mouse release
        if mouse_released {
            // Apply full edge sizing for Settings Panel on release
            if let Some(drag_idx) = self.dragging_widget {
                if let Some(widget) = self.widgets.get_mut(drag_idx) {
                        if !*minimized && *edge != CanvasEdge::None {
                            // Apply edge sizing based on final edge position - with reasonable constraints
                            match *edge {
                                CanvasEdge::Left => {
                                    widget.position = Pos2::new(self.canvas_rect.min.x, self.canvas_rect.min.y);
                                    widget.size = Vec2::new(*width, (self.canvas_rect.height() * 0.8).min(400.0));
                                }
                                CanvasEdge::Right => {
                                    widget.size = Vec2::new(*width, (self.canvas_rect.height() * 0.8).min(400.0));
                                    widget.position = Pos2::new(
                                        (self.canvas_rect.max.x - widget.size.x).max(self.canvas_rect.min.x),
                                        self.canvas_rect.min.y
                                    );
                                }
                                CanvasEdge::Top => {
                                    widget.position = Pos2::new(self.canvas_rect.min.x, self.canvas_rect.min.y);
                                    widget.size = Vec2::new((self.canvas_rect.width() * 0.8).min(600.0), *height);
                                }
                                CanvasEdge::Bottom => {
                                    widget.size = Vec2::new((self.canvas_rect.width() * 0.8).min(600.0), *height);
                                    widget.position = Pos2::new(
                                        self.canvas_rect.min.x,
                                        (self.canvas_rect.max.y - widget.size.y).max(self.canvas_rect.min.y)
                                    );
                                }
                                CanvasEdge::None => {
                                    // Keep current size for unsnapped panels
                                    widget.size = Vec2::new(*width, *height);
                                }
                            }
                        }
                    }
                }
            }
            
            // Check if widget was dragged out of any panel and remove it from containers
            if let Some(drag_idx) = self.dragging_widget {
                if let Some(widget) = self.widgets.get(drag_idx) {
                    let widget_rect = widget.get_rect();
                    let widget_id = widget.id;
                    
                    // Check if widget is still inside any panel it was originally in
                    let mut should_remove_from_all = true;
                    
                    for panel in &self.widgets {
                        if self.is_panel_accepting_widgets(panel) && panel.get_rect().contains(widget_rect.center()) {
                            should_remove_from_all = false;
                            break;
                        }
                    }
                    
                    // If widget is no longer inside any panel, remove it from all containers
                    if should_remove_from_all {
                        self.remove_widget_from_containers(widget_id);
                    }
                }
            }
            
            // Handle click interactions for widgets that were clicked but not dragged
            if let Some(drag_idx) = self.dragging_widget {
                if let Some(pos) = mouse_pos {
                    if let Some(widget) = self.widgets.get(drag_idx) {
                        let original_pos = pos - self.drag_offset;
                        let drag_distance = (widget.position - original_pos).length();
                        
                        // If the widget wasn't actually dragged (very small movement), treat it as a click
                        if drag_distance < 5.0 {
                            match widget.widget_type {
                                WidgetType::ToggleSwitch { .. } | 
                                WidgetType::PushButton { .. } | 
                                WidgetType::IconButton { .. } => {
                                    self.handle_widget_interaction(drag_idx, pos);
                                }
                                _ => {}
                            }
                        }
                    }
                }
            }
            
            self.dragging_widget = None;
            self.interacting_widget = None;
            self.resizing_widget = None;
            self.last_mouse_pos = None;
        }
    }

    fn handle_widget_interaction(&mut self, widget_idx: usize, mouse_pos: Pos2) {
        // Handle settings panel separately due to complex logic
        if let Some(widget) = self.widgets.get(widget_idx) {
                let was_minimized = *minimized;
                let current_edge = *edge;
                let current_width = *width;
                let current_height = *height;
                
                // Toggle minimized state
                if let Some(widget) = self.widgets.get_mut(widget_idx) {
                        *minimized = !*minimized;
                        
                        // Update widget size when toggling state
                        let new_size = if *minimized {
                            Vec2::new(40.0, 40.0)
                        } else {
                            // Calculate size based on edge - constrain to reasonable bounds
                            match current_edge {
                                CanvasEdge::Left | CanvasEdge::Right => Vec2::new(current_width, (self.canvas_rect.height() * 0.8).min(400.0)),
                                CanvasEdge::Top | CanvasEdge::Bottom => Vec2::new((self.canvas_rect.width() * 0.8).min(600.0), current_height),
                                CanvasEdge::None => Vec2::new(current_width, current_height),
                            }
                        };
                        
                        widget.size = new_size;
                        
                        // Also update position when expanding to ensure proper edge alignment
                        if was_minimized && !*minimized { // Expanding from minimized to full
                            match current_edge {
                                CanvasEdge::Left => {
                                    widget.position.x = self.canvas_rect.min.x;
                                    widget.position.y = self.canvas_rect.min.y;
                                }
                                CanvasEdge::Right => {
                                    widget.position.x = self.canvas_rect.max.x - widget.size.x;
                                    widget.position.y = self.canvas_rect.min.y;
                                }
                                CanvasEdge::Top => {
                                    widget.position.x = self.canvas_rect.min.x;
                                    widget.position.y = self.canvas_rect.min.y;
                                }
                                CanvasEdge::Bottom => {
                                    widget.position.x = self.canvas_rect.min.x;
                                    widget.position.y = self.canvas_rect.max.y - widget.size.y;
                                }
                                CanvasEdge::None => {} // No position change for unsnapped panels
                            }
                        }
                    }
                }
                return;
            }
        }
        
        // Handle all other widget types
        if let Some(widget) = self.widgets.get_mut(widget_idx) {
            let rect = widget.get_rect();
            match &mut widget.widget_type {
                WidgetType::Knob { value, min, max, .. } => {
                    let center = Pos2::new(rect.center().x, rect.top() + 37.0);
                    let mouse_vec = mouse_pos - center;
                    let angle = mouse_vec.y.atan2(mouse_vec.x);
                    let normalized_angle = (angle + 135.0 * PI / 180.0) / (270.0 * PI / 180.0);
                    *value = (normalized_angle.clamp(0.0, 1.0) * (*max - *min) + *min).clamp(*min, *max);
                }
                WidgetType::ToggleSwitch { on, .. } => {
                    *on = !*on;
                }
                WidgetType::PushButton { active, .. } => {
                    *active = !*active;
                }
                WidgetType::IconButton { active, .. } => {
                    *active = !*active;
                }
                WidgetType::HorizontalSlider { value, min, max, .. } => {
                    let slider_rect = Rect::from_center_size(
                        Pos2::new(rect.center().x + 10.0, rect.center().y),
                        Vec2::new(96.0, 8.0),
                    );
                    if slider_rect.contains(mouse_pos) {
                        let normalized = ((mouse_pos.x - slider_rect.left()) / slider_rect.width()).clamp(0.0, 1.0);
                        *value = normalized * (*max - *min) + *min;
                    }
                }
                WidgetType::VerticalSlider { value, min, max, .. } => {
                    let slider_rect = Rect::from_center_size(
                        Pos2::new(rect.center().x, rect.center().y - 10.0),
                        Vec2::new(8.0, 96.0),
                    );
                    if slider_rect.contains(mouse_pos) {
                        let normalized = 1.0 - ((mouse_pos.y - slider_rect.top()) / slider_rect.height()).clamp(0.0, 1.0);
                        *value = normalized * (*max - *min) + *min;
                    }
                }
                WidgetType::StatusBar { online, .. } => {
                    *online = !*online;
                }
                WidgetType::Panel { collapsed, .. } => {
                    *collapsed = !*collapsed;
                    
                    // Update widget size when toggling state
                    let new_size = if *collapsed {
                        Vec2::new(widget.size.x, 40.0) // Collapsed height
                    } else {
                        // Get original height from widget type
                        if let WidgetType::Panel { height, width, .. } = &widget.widget_type {
                            Vec2::new(*width, *height)
                        } else {
                            widget.size // Fallback
                        }
                    };
                    
                    // Update the widget's actual size
                    if let Some(widget) = self.widgets.get_mut(widget_idx) {
                        widget.size = new_size;
                    }
                }
                _ => {} // Other widgets don't have direct interactions yet
            }
        }
    }

    fn handle_knob_interaction(&mut self, widget_idx: usize, delta_y: f32) {
        if let Some(widget) = self.widgets.get_mut(widget_idx) {
            if let WidgetType::Knob { value, min, max, .. } = &mut widget.widget_type {
                let sensitivity = 0.5; // Adjust for desired sensitivity
                let range = *max - *min;
                let delta_value = (delta_y * sensitivity / 100.0) * range;
                *value = (*value + delta_value).clamp(*min, *max);
            }
        }
    }

    fn calculate_alignment_guides(&mut self, dragging_idx: usize, position: Pos2, size: Vec2) {
        self.alignment_guides.clear();
        let threshold = 8.0; // Distance threshold for showing guides
        
        // Canvas center guides
        let canvas_center_x = self.canvas_rect.center().x;
        let canvas_center_y = self.canvas_rect.center().y;
        let widget_center_x = position.x + size.x / 2.0;
        let widget_center_y = position.y + size.y / 2.0;
        
        // Check horizontal center alignment with canvas
        if (widget_center_x - canvas_center_x).abs() < threshold {
            self.alignment_guides.push(AlignmentGuide {
                start: Pos2::new(canvas_center_x, self.canvas_rect.min.y),
                end: Pos2::new(canvas_center_x, self.canvas_rect.max.y),
                guide_type: AlignmentType::CenterHorizontal,
            });
        }
        
        // Check vertical center alignment with canvas
        if (widget_center_y - canvas_center_y).abs() < threshold {
            self.alignment_guides.push(AlignmentGuide {
                start: Pos2::new(self.canvas_rect.min.x, canvas_center_y),
                end: Pos2::new(self.canvas_rect.max.x, canvas_center_y),
                guide_type: AlignmentType::CenterVertical,
            });
        }
        
        // Check alignment with other widgets
        for (idx, other_widget) in self.widgets.iter().enumerate() {
            if idx == dragging_idx {
                continue;
            }
            
            let other_center_x = other_widget.position.x + other_widget.size.x / 2.0;
            let other_center_y = other_widget.position.y + other_widget.size.y / 2.0;
            
            // Horizontal alignment with other widgets
            if (widget_center_x - other_center_x).abs() < threshold {
                self.alignment_guides.push(AlignmentGuide {
                    start: Pos2::new(other_center_x, other_widget.position.y.min(position.y) - 20.0),
                    end: Pos2::new(other_center_x, (other_widget.position.y + other_widget.size.y).max(position.y + size.y) + 20.0),
                    guide_type: AlignmentType::WidgetAlignHorizontal,
                });
            }
            
            // Vertical alignment with other widgets
            if (widget_center_y - other_center_y).abs() < threshold {
                self.alignment_guides.push(AlignmentGuide {
                    start: Pos2::new(other_widget.position.x.min(position.x) - 20.0, other_center_y),
                    end: Pos2::new((other_widget.position.x + other_widget.size.x).max(position.x + size.x) + 20.0, other_center_y),
                    guide_type: AlignmentType::WidgetAlignVertical,
                });
            }
            
            // Edge alignments (left, right, top, bottom)
            // Left edge alignment
            if (position.x - other_widget.position.x).abs() < threshold {
                self.alignment_guides.push(AlignmentGuide {
                    start: Pos2::new(other_widget.position.x, other_widget.position.y.min(position.y) - 20.0),
                    end: Pos2::new(other_widget.position.x, (other_widget.position.y + other_widget.size.y).max(position.y + size.y) + 20.0),
                    guide_type: AlignmentType::WidgetAlignHorizontal,
                });
            }
            
            // Right edge alignment
            if ((position.x + size.x) - (other_widget.position.x + other_widget.size.x)).abs() < threshold {
                let x = other_widget.position.x + other_widget.size.x;
                self.alignment_guides.push(AlignmentGuide {
                    start: Pos2::new(x, other_widget.position.y.min(position.y) - 20.0),
                    end: Pos2::new(x, (other_widget.position.y + other_widget.size.y).max(position.y + size.y) + 20.0),
                    guide_type: AlignmentType::WidgetAlignHorizontal,
                });
            }
            
            // Top edge alignment
            if (position.y - other_widget.position.y).abs() < threshold {
                self.alignment_guides.push(AlignmentGuide {
                    start: Pos2::new(other_widget.position.x.min(position.x) - 20.0, other_widget.position.y),
                    end: Pos2::new((other_widget.position.x + other_widget.size.x).max(position.x + size.x) + 20.0, other_widget.position.y),
                    guide_type: AlignmentType::WidgetAlignVertical,
                });
            }
            
            // Bottom edge alignment
            if ((position.y + size.y) - (other_widget.position.y + other_widget.size.y)).abs() < threshold {
                let y = other_widget.position.y + other_widget.size.y;
                self.alignment_guides.push(AlignmentGuide {
                    start: Pos2::new(other_widget.position.x.min(position.x) - 20.0, y),
                    end: Pos2::new((other_widget.position.x + other_widget.size.x).max(position.x + size.x) + 20.0, y),
                    guide_type: AlignmentType::WidgetAlignVertical,
                });
            }
        }
    }

    fn apply_snapping(&self, dragging_idx: usize, position: Pos2, size: Vec2) -> Pos2 {
        let mut final_pos = position;
        let snap_threshold = 8.0;
        
        // Snap to canvas center
        if (position.x + size.x / 2.0 - self.canvas_rect.center().x).abs() < snap_threshold {
            final_pos.x = self.canvas_rect.center().x - size.x / 2.0;
        }
        if (position.y + size.y / 2.0 - self.canvas_rect.center().y).abs() < snap_threshold {
            final_pos.y = self.canvas_rect.center().y - size.y / 2.0;
        }
        
        // Snap to other widgets
        for (idx, other_widget) in self.widgets.iter().enumerate() {
            if idx == dragging_idx {
                continue;
            }
            
            let other_center_x = other_widget.position.x + other_widget.size.x / 2.0;
            let other_center_y = other_widget.position.y + other_widget.size.y / 2.0;
            
            // Center alignments
            if (position.x + size.x / 2.0 - other_center_x).abs() < snap_threshold {
                final_pos.x = other_center_x - size.x / 2.0;
            }
            if (position.y + size.y / 2.0 - other_center_y).abs() < snap_threshold {
                final_pos.y = other_center_y - size.y / 2.0;
            }
            
            // Edge alignments
            if (position.x - other_widget.position.x).abs() < snap_threshold {
                final_pos.x = other_widget.position.x;
            }
            if (position.x + size.x - (other_widget.position.x + other_widget.size.x)).abs() < snap_threshold {
                final_pos.x = other_widget.position.x + other_widget.size.x - size.x;
            }
            if (position.y - other_widget.position.y).abs() < snap_threshold {
                final_pos.y = other_widget.position.y;
            }
            if (position.y + size.y - (other_widget.position.y + other_widget.size.y)).abs() < snap_threshold {
                final_pos.y = other_widget.position.y + other_widget.size.y - size.y;
            }
        }
        
        final_pos
    }

    // Removed unused positioning methods for cleaner architecture
    
    fn get_next_position_in_panel_for_widget(&self, panel_idx: usize, widget_id: Option<usize>) -> Pos2 {
        if let Some(panel) = self.widgets.get(panel_idx) {
            let panel_rect = panel.get_rect();
            
            // Start position within the panel (accounting for title bar)
            let start_x = panel_rect.left() + PANEL_MARGIN;
            let start_y = panel_rect.top() + PANEL_TITLE_HEIGHT + PANEL_MARGIN;
            
            // Get existing widgets in this panel
            let contained_widgets = match &panel.widget_type {
                WidgetType::Panel { contained_widgets, .. } => contained_widgets,
                WidgetType::Panel { contained_widgets, .. } => contained_widgets,
                _ => return Pos2::new(start_x, start_y),
            };
            
            // Count widgets excluding the one being positioned (if specified)
            let widget_count = if let Some(exclude_id) = widget_id {
                contained_widgets.iter().filter(|&&id| id != exclude_id).count()
            } else {
                contained_widgets.len()
            };
            
            // Simple grid layout - place widgets in rows
            let widgets_per_row = ((panel_rect.width() - (PANEL_MARGIN * 2.0)) / WIDGET_SPACING_IN_PANEL).max(1.0) as usize;
            let row = widget_count / widgets_per_row;
            let col = widget_count % widgets_per_row;
            
            let x = start_x + col as f32 * WIDGET_SPACING_IN_PANEL;
            let y = start_y + row as f32 * WIDGET_SPACING_IN_PANEL;
            
            // Make sure position is within panel bounds, but be more forgiving
            let widget_size = Vec2::new(60.0, 60.0);
            let max_x = panel_rect.right() - widget_size.x - PANEL_MARGIN;
            let max_y = panel_rect.bottom() - widget_size.y - PANEL_MARGIN;
            
            let final_x = x.min(max_x).max(start_x);
            let final_y = y.min(max_y).max(start_y);
            
            Pos2::new(final_x, final_y)
        } else {
            // Fallback to canvas center if available
            if self.canvas_rect != Rect::NOTHING {
                Pos2::new(self.canvas_rect.center().x, self.canvas_rect.center().y)
            } else {
                Pos2::new(400.0, 300.0)
            }
        }
    }

    // Canvas positioning logic moved to reposition_canvas_widgets for better organization
    
    fn reposition_canvas_widgets(&mut self) {
        // Use the new helper method to get canvas widgets
        let canvas_widget_indices = self.get_canvas_widgets();
        
        // Reposition each canvas widget using proper grid layout
        for (grid_position, &widget_idx) in canvas_widget_indices.iter().enumerate() {
            if let Some(widget) = self.widgets.get(widget_idx) {
                let widget_type = widget.widget_type.clone();
                let new_position = self.calculate_grid_position(grid_position, &widget_type);
                
                // Now update the position
                if let Some(widget_mut) = self.widgets.get_mut(widget_idx) {
                    widget_mut.position = new_position;
                }
            }
        }
    }
    
    fn calculate_grid_position(&self, grid_index: usize, widget_type: &WidgetType) -> Pos2 {
        let widget_size = DraggableWidget::calculate_size(widget_type);
        
        // Use canvas_rect or a safe fallback
        let canvas_rect = if self.canvas_rect == Rect::NOTHING {
            Rect::from_min_size(Pos2::ZERO, Vec2::new(800.0, 600.0))
        } else {
            self.canvas_rect
        };
        
        // Define the actual usable canvas area with simple margins
        let usable_start_x = canvas_rect.min.x + CANVAS_MARGIN;
        let usable_start_y = canvas_rect.min.y + CANVAS_MARGIN;
        let usable_end_x = (canvas_rect.max.x - CANVAS_MARGIN).max(usable_start_x + 100.0);
        let usable_end_y = (canvas_rect.max.y - CANVAS_MARGIN).max(usable_start_y + 100.0);
        
        // Grid layout with minimum spacing
        let available_width = usable_end_x - usable_start_x;
        let widgets_per_row = (available_width / GRID_SPACING).max(1.0) as usize;
        
        let row = grid_index / widgets_per_row;
        let col = grid_index % widgets_per_row;
        
        let x = usable_start_x + col as f32 * GRID_SPACING;
        let y = usable_start_y + row as f32 * GRID_SPACING;
        
        // Ensure position keeps widget fully within usable bounds
        let max_x = (usable_end_x - widget_size.x).max(usable_start_x);
        let max_y = (usable_end_y - widget_size.y).max(usable_start_y);
        
        Pos2::new(x.min(max_x), y.min(max_y))
    }

    fn check_and_place_in_panel(&mut self, widget_idx: usize, _drop_pos: Pos2) {
        // Find which panel (if any) the widget was dropped on using proper layering
        let mut target_panel_idx = None;
        let mut highest_layer = -1; // Higher numbers = higher layer (rendered later = on top)
        
        if let Some(dragged_widget) = self.widgets.get(widget_idx) {
            let widget_rect = dragged_widget.get_rect();
            
            for (idx, panel) in self.widgets.iter().enumerate() {
                if idx == widget_idx {
                    continue; // Skip the widget being dragged
                }
                
                if self.is_panel_accepting_widgets(panel) {
                    let panel_rect = panel.get_rect();
                    
                    // Check if widget center is inside this panel
                    if panel_rect.contains(widget_rect.center()) {
                        // Calculate layer based on containment depth and render order
                        let layer = self.get_panel_layer(idx);
                        
                        if layer > highest_layer {
                            highest_layer = layer;
                            target_panel_idx = Some(idx);
                        }
                    }
                }
            }
        }
        
        if let Some(panel_idx) = target_panel_idx {
            if let Some(dragged_widget) = self.widgets.get(widget_idx) {
                let _widget_size = dragged_widget.size;
                let widget_id = dragged_widget.id;
                
                // Auto-resizing functionality removed as requested by user
                
                // For panels, keep the dragged position but constrain to container bounds
                // For other widgets, use grid positioning
                let new_position = if matches!(dragged_widget.widget_type, WidgetType::Panel { .. }) {
                    // Keep the current dragged position but constrain it to the container panel bounds
                    let container_panel = &self.widgets[panel_idx];
                    let container_rect = container_panel.get_rect();
                    let content_area = Rect::from_min_size(
                        Pos2::new(container_rect.left() + PANEL_MARGIN, container_rect.top() + PANEL_TITLE_HEIGHT),
                        Vec2::new((container_rect.width() - PANEL_MARGIN * 2.0).max(50.0), (container_rect.height() - PANEL_TITLE_HEIGHT - PANEL_MARGIN).max(50.0)),
                    );
                    
                    // Constrain the widget's current position to fit within the content area
                    let current_pos = dragged_widget.position;
                    let widget_size = dragged_widget.size;
                    let max_x = (content_area.max.x - widget_size.x).max(content_area.min.x);
                    let max_y = (content_area.max.y - widget_size.y).max(content_area.min.y);
                    
                    Pos2::new(
                        current_pos.x.clamp(content_area.min.x, max_x),
                        current_pos.y.clamp(content_area.min.y, max_y),
                    )
                } else {
                    // Use grid positioning for regular widgets
                    self.get_next_position_in_panel_for_widget(panel_idx, Some(widget_id))
                };
                
                // Remove widget from any existing containers first
                self.remove_widget_from_containers(widget_id);
                
                // Update widget position and add to panel
                if let Some(widget_mut) = self.widgets.get_mut(widget_idx) {
                    widget_mut.position = new_position;
                }
                
                // Add widget to panel's contained_widgets list
                self.add_widget_to_panel(panel_idx, widget_id);
            }
        }
    }

    fn find_panel_under_position(&self, pos: Pos2) -> Option<usize> {
        for (_idx, widget) in self.widgets.iter().enumerate() {
            if self.is_panel_accepting_widgets(widget) && widget.get_rect().contains(pos) {
                return Some(widget.id);
            }
        }
        None
    }

    fn is_widget_in_minimized_panel(&self, widget_id: usize) -> bool {
        self.is_widget_in_minimized_panel_recursive(widget_id, &mut std::collections::HashSet::new())
    }
    
    fn is_widget_in_minimized_panel_recursive(&self, widget_id: usize, visited: &mut std::collections::HashSet<usize>) -> bool {
        // Prevent infinite recursion
        if visited.contains(&widget_id) {
            return false;
        }
        visited.insert(widget_id);
        
        // Check if widget is directly in a minimized/collapsed panel
        for widget in &self.widgets {
            match &widget.widget_type {
                    if *minimized && contained_widgets.contains(&widget_id) {
                        return true;
                    }
                }
                WidgetType::Panel { collapsed, contained_widgets, .. } => {
                    if *collapsed && contained_widgets.contains(&widget_id) {
                        return true;
                    }
                }
                _ => {}
            }
        }
        
        // Check if widget is in a panel that is itself in a minimized panel (nested case)
        if let Some(container_panel_idx) = self.find_widget_container_panel_id(widget_id) {
            if let Some(container_panel) = self.widgets.iter().find(|w| w.id == container_panel_idx) {
                return self.is_widget_in_minimized_panel_recursive(container_panel.id, visited);
            }
        }
        
        false
    }
    
    fn find_widget_container_panel_id(&self, widget_id: usize) -> Option<usize> {
        for widget in &self.widgets {
            match &widget.widget_type {
                WidgetType::Panel { contained_widgets, .. } |
                WidgetType::Panel { contained_widgets, .. } => {
                    if contained_widgets.contains(&widget_id) {
                        return Some(widget.id);
                    }
                }
                _ => {}
            }
        }
        None
    }

    fn calculate_edge_snap(&self, position: Pos2, size: Vec2) -> CanvasEdge {
        let snap_threshold = 50.0; // Distance from edge to trigger snapping
        
        // For settings panels, only allow left/right snapping
        let distances = [
            (CanvasEdge::Left, position.x - self.canvas_rect.min.x),
            (CanvasEdge::Right, self.canvas_rect.max.x - (position.x + size.x)),
        ];
        
        // Find the closest edge within snap threshold
        let closest_edge = distances
            .iter()
            .filter(|(_, distance)| *distance < snap_threshold)
            .min_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
        
        match closest_edge {
            Some((edge, _)) => *edge,
            None => CanvasEdge::None,
        }
    }

    pub fn show_widget_palette(&mut self, ui: &mut Ui) {
        ui.group(|ui| {
            ui.set_min_width(200.0);
            ui.label(RichText::new("Widget Palette").size(16.0).color(WHITE));
            ui.label(RichText::new(format!("Ev2 v{}", APP_VERSION)).size(10.0).color(GRAY_400));
            ui.separator();

            ui.vertical(|ui| {
                // Instructions
                if self.pending_widget.is_some() {
                    ui.colored_label(CYAN, "â†’ Widget selected - click to place");
                } else {
                    ui.label("Click a widget to select it");
                    ui.label("Then click where to place it");
                }
                ui.separator();
                
                // Knobs
                let knob_btn = ui.button("ðŸŽ›ï¸ Knob");
                if knob_btn.clicked() {
                    self.pending_widget = Some(WidgetType::Knob {
                        value: 50.0,
                        min: 0.0,
                        max: 100.0,
                        label: "KNOB".to_string(),
                        color: WidgetColor::Cyan,
                    });
                }
                
                // Check for drag start on knob button
                if knob_btn.drag_started() || (knob_btn.hovered() && ui.input(|i| i.pointer.primary_pressed())) {
                    self.palette_dragging = Some(WidgetType::Knob {
                        value: 50.0,
                        min: 0.0,
                        max: 100.0,
                        label: "KNOB".to_string(),
                        color: WidgetColor::Cyan,
                    });
                }

                // Toggle Switch
                let toggle_btn = ui.button("ðŸ”˜ Toggle");
                if toggle_btn.clicked() {
                    self.pending_widget = Some(WidgetType::ToggleSwitch {
                        on: false,
                        label: "TOGGLE".to_string(),
                        color: WidgetColor::Cyan,
                        glow: true,
                    });
                }
                
                // Check for drag start on toggle button
                if toggle_btn.drag_started() || (toggle_btn.hovered() && ui.input(|i| i.pointer.primary_pressed())) {
                    self.palette_dragging = Some(WidgetType::ToggleSwitch {
                        on: false,
                        label: "TOGGLE".to_string(),
                        color: WidgetColor::Cyan,
                        glow: true,
                    });
                }

                // Push Button
                let button_btn = ui.button("ðŸ”³ Button");
                if button_btn.clicked() {
                    self.pending_widget = Some(WidgetType::PushButton {
                        active: false,
                        icon: "â–¶".to_string(),
                        label: "PLAY".to_string(),
                        color: WidgetColor::Green,
                        size: 48.0,
                    });
                }
                
                // Check for drag start on button
                if button_btn.drag_started() || (button_btn.hovered() && ui.input(|i| i.pointer.primary_pressed())) {
                    self.palette_dragging = Some(WidgetType::PushButton {
                        active: false,
                        icon: "â–¶".to_string(),
                        label: "PLAY".to_string(),
                        color: WidgetColor::Green,
                        size: 48.0,
                    });
                }

                // VU Meter
                let vu_btn = ui.button("ðŸ“Š VU Meter");
                if vu_btn.clicked() {
                    self.pending_widget = Some(WidgetType::VuMeter {
                        level: 75.0,
                        peak_level: 80.0,
                        label: "VU".to_string(),
                        color: WidgetColor::Green,
                    });
                }
                
                // Check for drag start on VU meter button
                if vu_btn.drag_started() {
                    self.palette_dragging = Some(WidgetType::VuMeter {
                        level: 75.0,
                        peak_level: 80.0,
                        label: "VU".to_string(),
                        color: WidgetColor::Green,
                    });
                }

                // Horizontal Slider
                let h_slider_btn = ui.button("â” H.Slider");
                if h_slider_btn.clicked() {
                    self.pending_widget = Some(WidgetType::HorizontalSlider {
                        value: 60.0,
                        min: 0.0,
                        max: 100.0,
                        label: "LEVEL".to_string(),
                        color: WidgetColor::Yellow,
                    });
                }
                
                // Check for drag start on horizontal slider button
                if h_slider_btn.drag_started() {
                    self.palette_dragging = Some(WidgetType::HorizontalSlider {
                        value: 60.0,
                        min: 0.0,
                        max: 100.0,
                        label: "LEVEL".to_string(),
                        color: WidgetColor::Yellow,
                    });
                }

                // Vertical Slider
                let v_slider_btn = ui.button("â”ƒ V.Slider");
                if v_slider_btn.clicked() {
                    self.pending_widget = Some(WidgetType::VerticalSlider {
                        value: 75.0,
                        min: 0.0,
                        max: 100.0,
                        label: "CH1".to_string(),
                        color: WidgetColor::Pink,
                    });
                }
                
                // Check for drag start on vertical slider button
                if v_slider_btn.drag_started() {
                    self.palette_dragging = Some(WidgetType::VerticalSlider {
                        value: 75.0,
                        min: 0.0,
                        max: 100.0,
                        label: "CH1".to_string(),
                        color: WidgetColor::Pink,
                    });
                }

                // Level Indicator
                let level_btn = ui.button("â–­â–­â–­ Level");
                if level_btn.clicked() {
                    self.pending_widget = Some(WidgetType::LevelIndicator {
                        level: 62.5,
                        segments: 8,
                        label: "INPUT".to_string(),
                    });
                }
                
                // Check for drag start on level indicator button
                if level_btn.drag_started() {
                    self.palette_dragging = Some(WidgetType::LevelIndicator {
                        level: 62.5,
                        segments: 8,
                        label: "INPUT".to_string(),
                    });
                }

                // Text Label
                let label_btn = ui.button("ðŸ·ï¸ Label");
                if label_btn.clicked() {
                    self.pending_widget = Some(WidgetType::TextLabel {
                        text: "LABEL".to_string(),
                        size: 16.0,
                        color: WidgetColor::Cyan,
                    });
                }
                
                // Check for drag start on text label button
                if label_btn.drag_started() {
                    self.palette_dragging = Some(WidgetType::TextLabel {
                        text: "LABEL".to_string(),
                        size: 16.0,
                        color: WidgetColor::Cyan,
                    });
                }

                // Panel
                let panel_btn = ui.button("ðŸ“¦ Panel");
                if panel_btn.clicked() {
                    self.pending_widget = Some(WidgetType::Panel {
                        title: "CONTROL PANEL".to_string(),
                        color: WidgetColor::Cyan,
                        width: 200.0,
                        height: 150.0,
                        collapsed: false,
                        contained_widgets: Vec::new(),
                        minimize_to_settings_icon: false,
                    });
                }
                
                // Check for drag start on panel button
                if panel_btn.drag_started() {
                    self.palette_dragging = Some(WidgetType::Panel {
                        title: "CONTROL PANEL".to_string(),
                        color: WidgetColor::Cyan,
                        width: 200.0,
                        height: 150.0,
                        collapsed: false,
                        contained_widgets: Vec::new(),
                    });
                }
                
                // Status Bar
                let status_btn = ui.button("ðŸ“Š Status Bar");
                if status_btn.clicked() {
                    self.pending_widget = Some(WidgetType::StatusBar {
                        cpu: 23.0,
                        ram: 1.2,
                        latency: 2.3,
                        online: true,
                    });
                }
                
                // Check for drag start on status bar button
                if status_btn.drag_started() {
                    self.palette_dragging = Some(WidgetType::StatusBar {
                        cpu: 23.0,
                        ram: 1.2,
                        latency: 2.3,
                        online: true,
                    });
                }
                
                // Settings Widget
                let settings_btn = ui.button("âš™ï¸ Settings");
                if settings_btn.clicked() {
                    self.pending_widget = Some(WidgetType::Settings {
                        label: "SETTINGS".to_string(),
                        color: WidgetColor::Cyan,
                    });
                }
                
                // Check for drag start on settings button
                if settings_btn.drag_started() {
                    self.palette_dragging = Some(WidgetType::Settings {
                        label: "SETTINGS".to_string(),
                        color: WidgetColor::Cyan,
                    });
                }
                
                ui.separator();
                ui.label("Icon Buttons:");
                
                // Icon buttons
                ui.horizontal_wrapped(|ui| {
                    let power_btn = ui.button("â» Power");
                    if power_btn.clicked() {
                        self.pending_widget = Some(WidgetType::IconButton {
                            icon: IconType::Power,
                            label: "POWER".to_string(),
                            active: false,
                            color: WidgetColor::Green,
                            size: 48.0,
                        });
                    }
                    
                    // Check for drag start on power button
                    if power_btn.drag_started() {
                        self.palette_dragging = Some(WidgetType::IconButton {
                            icon: IconType::Power,
                            label: "POWER".to_string(),
                            active: false,
                            color: WidgetColor::Green,
                            size: 48.0,
                        });
                    }
                    
                    let play_btn = ui.button("â–¶ Play");
                    if play_btn.clicked() {
                        self.pending_widget = Some(WidgetType::IconButton {
                            icon: IconType::Play,
                            label: "PLAY".to_string(),
                            active: false,
                            color: WidgetColor::Cyan,
                            size: 48.0,
                        });
                    }
                    
                    // Check for drag start on play button
                    if play_btn.drag_started() {
                        self.palette_dragging = Some(WidgetType::IconButton {
                            icon: IconType::Play,
                            label: "PLAY".to_string(),
                            active: false,
                            color: WidgetColor::Cyan,
                            size: 48.0,
                        });
                    }
                    
                    let pause_btn = ui.button("â¸ Pause");
                    if pause_btn.clicked() {
                        self.pending_widget = Some(WidgetType::IconButton {
                            icon: IconType::Pause,
                            label: "PAUSE".to_string(),
                            active: false,
                            color: WidgetColor::Cyan,
                            size: 48.0,
                        });
                    }
                    
                    // Check for drag start on pause button
                    if pause_btn.drag_started() {
                        self.palette_dragging = Some(WidgetType::IconButton {
                            icon: IconType::Pause,
                            label: "PAUSE".to_string(),
                            active: false,
                            color: WidgetColor::Cyan,
                            size: 48.0,
                        });
                    }
                    
                    let settings_btn = ui.button("âš™ Settings");
                    if settings_btn.clicked() {
                        self.pending_widget = Some(WidgetType::IconButton {
                            icon: IconType::Settings,
                            label: "CONFIG".to_string(),
                            active: false,
                            color: WidgetColor::Yellow,
                            size: 48.0,
                        });
                    }
                    
                    // Check for drag start on settings button
                    if settings_btn.drag_started() {
                        self.palette_dragging = Some(WidgetType::IconButton {
                            icon: IconType::Settings,
                            label: "CONFIG".to_string(),
                            active: false,
                            color: WidgetColor::Yellow,
                            size: 48.0,
                        });
                    }
                    
                    let mic_btn = ui.button("ðŸŽ¤ Mic");
                    if mic_btn.clicked() {
                        self.pending_widget = Some(WidgetType::IconButton {
                            icon: IconType::Mic,
                            label: "MIC".to_string(),
                            active: false,
                            color: WidgetColor::Pink,
                            size: 40.0,
                        });
                    }
                    
                    // Check for drag start on mic button
                    if mic_btn.drag_started() {
                        self.palette_dragging = Some(WidgetType::IconButton {
                            icon: IconType::Mic,
                            label: "MIC".to_string(),
                            active: false,
                            color: WidgetColor::Pink,
                            size: 40.0,
                        });
                    }
                    
                    let mute_btn = ui.button("ðŸ”‡ Mute");
                    if mute_btn.clicked() {
                        self.pending_widget = Some(WidgetType::IconButton {
                            icon: IconType::Mute,
                            label: "MUTE".to_string(),
                            active: false,
                            color: WidgetColor::Red,
                            size: 40.0,
                        });
                    }
                    
                    // Check for drag start on mute button
                    if mute_btn.drag_started() {
                        self.palette_dragging = Some(WidgetType::IconButton {
                            icon: IconType::Mute,
                            label: "MUTE".to_string(),
                            active: false,
                            color: WidgetColor::Red,
                            size: 40.0,
                        });
                    }
                });
            });

            ui.separator();
            
            // Canvas Management
            ui.label(RichText::new("Canvas Management").size(14.0).color(YELLOW));
            
            ui.horizontal(|ui| {
                if ui.button("ðŸ’¾ Save Layout").clicked() {
                    self.save_layout();
                }
                if ui.button("ðŸ—‘ï¸ Clear Canvas").clicked() {
                    self.clear_canvas();
                }
            });
            
            ui.separator();
            
            ui.separator();
            
            // Show drag hint
            ui.label("Drag widgets to panels to organize them");
            
            ui.separator();
            ui.label("Click to add widgets");
            ui.label("Right-click to edit");
            
        });
    }

    fn show_edit_window(&mut self, ui: &mut Ui) {
        if let Some(idx) = self.editing_widget {
            let mut open = self.show_edit_window;
            let mut delete_widget = false;
            
            if let Some(widget) = self.widgets.get_mut(idx) {
                egui::Window::new("Edit Widget")
                    .open(&mut open)
                    .show(ui.ctx(), |ui| {
                        match &mut widget.widget_type {
                            WidgetType::Knob { value, min, max, label, color } => {
                                ui.label("Knob Properties:");
                                ui.add(egui::Slider::new(value, *min..=*max).text("Value"));
                                ui.add(egui::Slider::new(min, 0.0..=100.0).text("Min"));
                                ui.add(egui::Slider::new(max, 0.0..=200.0).text("Max"));
                                ui.text_edit_singleline(label);
                                ui.horizontal(|ui| {
                                    ui.label("Color:");
                                    if ui.radio_value(color, WidgetColor::Cyan, "Cyan").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Pink, "Pink").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Green, "Green").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Yellow, "Yellow").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Red, "Red").clicked() {}
                                });
                            }
                            WidgetType::ToggleSwitch { on, label, color, glow } => {
                                ui.label("Toggle Switch Properties:");
                                ui.checkbox(on, "Current State");
                                ui.checkbox(glow, "Glow Effect");
                                ui.text_edit_singleline(label);
                                ui.horizontal(|ui| {
                                    ui.label("Color:");
                                    if ui.radio_value(color, WidgetColor::Cyan, "Cyan").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Pink, "Pink").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Green, "Green").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Yellow, "Yellow").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Red, "Red").clicked() {}
                                });
                            }
                            WidgetType::PushButton { active, icon, label, color, size } => {
                                ui.label("Push Button Properties:");
                                ui.checkbox(active, "Active State");
                                ui.text_edit_singleline(icon);
                                ui.text_edit_singleline(label);
                                ui.add(egui::Slider::new(size, 20.0..=100.0).text("Size"));
                                ui.horizontal(|ui| {
                                    ui.label("Color:");
                                    if ui.radio_value(color, WidgetColor::Cyan, "Cyan").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Pink, "Pink").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Green, "Green").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Yellow, "Yellow").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Red, "Red").clicked() {}
                                });
                            }
                            WidgetType::VuMeter { level, peak_level, label, color } => {
                                ui.label("VU Meter Properties:");
                                ui.add(egui::Slider::new(level, 0.0..=100.0).text("Level"));
                                ui.add(egui::Slider::new(peak_level, 0.0..=100.0).text("Peak Level"));
                                ui.text_edit_singleline(label);
                                ui.horizontal(|ui| {
                                    ui.label("Color:");
                                    if ui.radio_value(color, WidgetColor::Cyan, "Cyan").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Pink, "Pink").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Green, "Green").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Yellow, "Yellow").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Red, "Red").clicked() {}
                                });
                            }
                            WidgetType::HorizontalSlider { value, min, max, label, color } => {
                                ui.label("Horizontal Slider Properties:");
                                ui.add(egui::Slider::new(value, *min..=*max).text("Value"));
                                ui.add(egui::Slider::new(min, 0.0..=100.0).text("Min"));
                                ui.add(egui::Slider::new(max, 0.0..=200.0).text("Max"));
                                ui.text_edit_singleline(label);
                                ui.horizontal(|ui| {
                                    ui.label("Color:");
                                    if ui.radio_value(color, WidgetColor::Cyan, "Cyan").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Pink, "Pink").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Green, "Green").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Yellow, "Yellow").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Red, "Red").clicked() {}
                                });
                            }
                            WidgetType::VerticalSlider { value, min, max, label, color } => {
                                ui.label("Vertical Slider Properties:");
                                ui.add(egui::Slider::new(value, *min..=*max).text("Value"));
                                ui.add(egui::Slider::new(min, 0.0..=100.0).text("Min"));
                                ui.add(egui::Slider::new(max, 0.0..=200.0).text("Max"));
                                ui.text_edit_singleline(label);
                                ui.horizontal(|ui| {
                                    ui.label("Color:");
                                    if ui.radio_value(color, WidgetColor::Cyan, "Cyan").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Pink, "Pink").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Green, "Green").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Yellow, "Yellow").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Red, "Red").clicked() {}
                                });
                            }
                            WidgetType::LevelIndicator { level, segments, label } => {
                                ui.label("Level Indicator Properties:");
                                ui.add(egui::Slider::new(level, 0.0..=100.0).text("Level"));
                                ui.add(egui::Slider::new(segments, 4..=16).text("Segments"));
                                ui.text_edit_singleline(label);
                            }
                            WidgetType::TextLabel { text, size, color } => {
                                ui.label("Text Label Properties:");
                                ui.text_edit_singleline(text);
                                ui.add(egui::Slider::new(size, 8.0..=32.0).text("Font Size"));
                                ui.horizontal(|ui| {
                                    ui.label("Color:");
                                    if ui.radio_value(color, WidgetColor::Cyan, "Cyan").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Pink, "Pink").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Green, "Green").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Yellow, "Yellow").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Red, "Red").clicked() {}
                                });
                            }
                            WidgetType::Panel { title, color, width, height, collapsed, contained_widgets } => {
                                ui.label("Panel Properties:");
                                ui.text_edit_singleline(title);
                                ui.add(egui::Slider::new(width, 100.0..=400.0).text("Width"));
                                ui.add(egui::Slider::new(height, 100.0..=300.0).text("Height"));
                                ui.checkbox(collapsed, "Collapsed");
                                ui.label(format!("Contains {} widgets", contained_widgets.len()));
                                ui.horizontal(|ui| {
                                    ui.label("Color:");
                                    if ui.radio_value(color, WidgetColor::Cyan, "Cyan").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Pink, "Pink").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Green, "Green").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Yellow, "Yellow").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Red, "Red").clicked() {}
                                });
                            }
                            WidgetType::StatusBar { cpu, ram, latency, online } => {
                                ui.label("Status Bar Properties:");
                                ui.add(egui::Slider::new(cpu, 0.0..=100.0).text("CPU %"));
                                ui.add(egui::Slider::new(ram, 0.0..=8.0).text("RAM (GB)"));
                                ui.add(egui::Slider::new(latency, 0.0..=100.0).text("Latency (ms)"));
                                ui.checkbox(online, "System Online");
                            }
                            WidgetType::IconButton { icon, label, active, color, size } => {
                                ui.label("Icon Button Properties:");
                                ui.checkbox(active, "Active State");
                                ui.text_edit_singleline(label);
                                ui.add(egui::Slider::new(size, 20.0..=80.0).text("Size"));
                                
                                ui.horizontal(|ui| {
                                    ui.label("Icon:");
                                    ui.selectable_value(icon, IconType::Power, "Power");
                                    ui.selectable_value(icon, IconType::Play, "Play");
                                    ui.selectable_value(icon, IconType::Pause, "Pause");
                                });
                                ui.horizontal(|ui| {
                                    ui.selectable_value(icon, IconType::Settings, "Settings");
                                    ui.selectable_value(icon, IconType::Mic, "Mic");
                                    ui.selectable_value(icon, IconType::Mute, "Mute");
                                });
                                
                                ui.horizontal(|ui| {
                                    ui.label("Color:");
                                    if ui.radio_value(color, WidgetColor::Cyan, "Cyan").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Pink, "Pink").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Green, "Green").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Yellow, "Yellow").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Red, "Red").clicked() {}
                                });
                            }
                                ui.label("Settings Panel Properties:");
                                ui.text_edit_singleline(title);
                                ui.add(egui::Slider::new(width, 150.0..=400.0).text("Width"));
                                ui.add(egui::Slider::new(height, 200.0..=500.0).text("Height"));
                                ui.checkbox(minimized, "Minimized");
                                ui.label(format!("Contains {} widgets", contained_widgets.len()));
                                
                                ui.horizontal(|ui| {
                                    ui.label("Edge Snap:");
                                    ui.selectable_value(edge, CanvasEdge::None, "None");
                                    ui.selectable_value(edge, CanvasEdge::Left, "Left");
                                    ui.selectable_value(edge, CanvasEdge::Right, "Right");
                                });
                                ui.horizontal(|ui| {
                                    ui.selectable_value(edge, CanvasEdge::Top, "Top");
                                    ui.selectable_value(edge, CanvasEdge::Bottom, "Bottom");
                                });
                                
                                ui.horizontal(|ui| {
                                    ui.label("Color:");
                                    if ui.radio_value(color, WidgetColor::Cyan, "Cyan").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Pink, "Pink").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Green, "Green").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Yellow, "Yellow").clicked() {}
                                    if ui.radio_value(color, WidgetColor::Red, "Red").clicked() {}
                                });
                            }
                        }
                        
                        ui.separator();
                        if ui.button("Delete Widget").clicked() {
                            delete_widget = true;
                        }
                    });
            }
            
            self.show_edit_window = open;
            
            if delete_widget {
                self.widgets.remove(idx);
                self.editing_widget = None;
                self.show_edit_window = false;
            }
        } else {
            self.show_edit_window = false;
        }
        
        if !self.show_edit_window {
            self.editing_widget = None;
        }
    }
    
    fn render_settings_icon(&self, ui: &mut Ui) {
        let _icon_size = 30.0;
        let padding = 15.0;
        let icon_pos = Pos2::new(padding, padding);
        
        let painter = ui.painter();
        
        // Simple static settings icon
        painter.text(
            icon_pos,
            Align2::LEFT_TOP,
            "âš™ï¸",
            FontId::monospace(20.0),
            Color32::from_rgba_unmultiplied(156, 163, 175, 200), // Semi-transparent gray
        );
    }
    
    
    pub fn save_layout(&self) {
        // For now, just print to console - could be extended to save to file
        println!("ðŸ’¾ Layout saved! {} widgets on canvas", self.widgets.len());
        
        // In a real implementation, you would serialize self.widgets and self.config_panel.items
        // and save them to a file or local storage
        
        // Example of what could be saved:
        for (i, widget) in self.widgets.iter().enumerate() {
            println!("  Widget {}: {:?} at {:?}", i, widget.widget_type, widget.position);
        }
    }
    
    pub fn clear_canvas(&mut self) {
        self.widgets.clear();
        println!("ðŸ—‘ï¸ Canvas cleared!");
    }
    
    fn find_widget_container_panel(&self, widget_idx: usize) -> Option<usize> {
        if let Some(widget) = self.widgets.get(widget_idx) {
            let widget_id = widget.id;
            
            // Find any SettingsPanel or Panel that contains this widget
            for (idx, panel_widget) in self.widgets.iter().enumerate() {
                match &panel_widget.widget_type {
                    WidgetType::Panel { contained_widgets, .. } |
                    WidgetType::Panel { contained_widgets, .. } => {
                        if contained_widgets.contains(&widget_id) {
                            return Some(idx);
                        }
                    }
                    _ => {}
                }
            }
        }
        None
    }
    
    // Legacy drop logic removed - using check_and_place_in_panel for all placement
    
    fn get_panel_layer(&self, panel_idx: usize) -> i32 {
        // Calculate the layer based on containment depth
        // Higher depth = higher layer number = rendered on top
        let mut layer = 0;
        
        if let Some(panel) = self.widgets.get(panel_idx) {
            // Check if this panel is contained in another panel
            for other_panel in &self.widgets {
                match &other_panel.widget_type {
                    WidgetType::Panel { contained_widgets, .. } |
                    WidgetType::Panel { contained_widgets, .. } => {
                        if contained_widgets.contains(&panel.id) {
                            // This panel is contained in another panel, so it's at least layer 1
                            layer = layer.max(1);
                            
                            // Recursively calculate the layer of the container
                            if let Some(container_idx) = self.widgets.iter().position(|w| w.id == other_panel.id) {
                                layer = layer.max(self.get_panel_layer(container_idx) + 1);
                            }
                        }
                    }
                    _ => {}
                }
            }
            
            // Add the position in the widgets array as a tie-breaker (later widgets rendered on top)
            layer += panel_idx as i32 / 1000; // Small increment to preserve order
        }
        
        layer
    }
    
    fn remove_widget_from_containers(&mut self, widget_id: usize) {
        for widget in &mut self.widgets {
            match &mut widget.widget_type {
                WidgetType::Panel { contained_widgets, .. } => {
                    contained_widgets.retain(|&id| id != widget_id);
                }
                _ => {}
            }
        }
    }
    
    fn render_settings_widget(painter: &egui::Painter, rect: Rect, label: &str, color: WidgetColor) {
        // Draw background
        painter.rect_filled(rect, 8.0, GRAY_900);
        
        // Draw gradient background
        let gradient_color = Color32::from_rgba_unmultiplied(
            color.to_color32().r(),
            color.to_color32().g(),
            color.to_color32().b(),
            20
        );
        painter.rect_filled(rect.shrink(2.0), 8.0, gradient_color);
        
        // Draw settings icon
        painter.text(
            rect.center(),
            Align2::CENTER_CENTER,
            "âš™ï¸",
            FontId::monospace(20.0),
            color.to_color32(),
        );
        
        // Draw label below if provided
        if !label.is_empty() {
            painter.text(
                Pos2::new(rect.center().x, rect.bottom() - 5.0),
                Align2::CENTER_BOTTOM,
                label,
                FontId::monospace(8.0),
                GRAY_400,
            );
        }
    }
}